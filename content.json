{"pages":[{"title":"","text":"个人简介# 分享很喜欢的**老罗**的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息# 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引# 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划#2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录#","link":"/about/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"碎碎念# tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"ESP8266开发学习笔记_Ubuntu系统安装","text":"③ESP8266 开发学习笔记_By_GYC 【虚拟机Ubuntu系统的安装】 一、获取最新稳定版本的Ubuntu系统安装包。 二、软件安装 4、代码编辑器VSCode 5、git 6、其他软件 三、接下来 ③ESP8266 开发学习笔记_By_GYC 【虚拟机Ubuntu系统的安装】#本来是想最后有时间再写这篇博客的，奈何皂滑弄人，昨天晚上在写上一篇还未出世的博客文章的时候，手滑更新了一下ubuntu系统，再加之前几天更新了主机的显卡驱动，我的Ubuntu虚拟机挂了，驱动不兼容在无法加载登陆界面。虽然通过一些骚操作能够进入桌面系统，但已经不是最好的Linux体验了，所以打算重新安装最新版本的Ubuntu系统，重新搭建一下开发环境。正好填一下自己留的坑，记录一下这次虚拟机Ubuntu系统搭建的过程。 一、获取最新稳定版本的Ubuntu系统安装包。#百度Ubuntu 第一个条目就是Ubuntu系统的官方下载 选择稳定版本的Download 等待迅雷下载完成 打开VM虚拟机-&gt;创建一个新的虚拟机 选择典型虚拟机 使用光盘镜像安装 文件定位到我们刚刚下载的Ubuntu安装包（*.iso文件） 给你的系统起个名字 填入自己想要的用户名和密码 因为我可能会存比较多的文件，Linux磁盘大小设置为40G ，拆分为多个文件 根据自己的电脑情况，自定义一下硬件： 最后点击完成，等待简易安装自动完成 就可以了。 二、软件安装 #1、安装好后系统会推荐你安装一些软件，你可以根据自己的需要或者兴趣点击进行安装。 2、因为是在VM虚拟机中，所以需要安装VM Tools，方便虚拟机和主机文件互传等操作。 emmmm 我一不留神，VM Tools自己装好了，如果你的虚拟机没有帮你完成，可以在虚拟机选项卡上右击手动选择安装VMware Tools。 3、切换软件安装源 因为国外网络访问速度问题，推荐大家切换最适合自己的软件安装镜像，ubuntu系统中就直接提供了这些功能，我们可以很快的通过图形界面进行切换，切换合适的镜像之后，下载速度基本可以达到满速。 常用命令 sudo apt-get update sudo apt upgrade 4、代码编辑器VSCode#只需要在终端中敲入一行代码 sudo snap install code –classic 5、git#要给系统安装git，使用如下命令，方便后续和github连接获取仓库中的文件 sudo apt install git 6、其他软件#遇到再更新。 至此我们就在windows系统下安装完成了Ubuntu版本的Linux环境了。 三、接下来#接下来我会再Ubuntu系统上安装ESP8266的交叉工具链，配置ESP-IDF开发环境。在下一篇博文中单独列出。","link":"/2020/08/09/ESP8266%E7%AC%94%E8%AE%B0_Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"title":"ESP8266开发学习笔记_浮点数打印支持","text":"① ESP8266 开发学习笔记_By_GYC 【更新 ets_printf 函数 使ESP_IDF 能够支持浮点数打印】 一、启用ets_printf函数 二、修改ets_printf函数 三、直接使用 ① ESP8266 开发学习笔记_By_GYC 【更新 ets_printf 函数 使ESP_IDF 能够支持浮点数打印】#在我们日常的开发过程中，经常使用到的一个功能就是串口打印功能。在ESP8266的IDF框架中，提供了类似控制台的printf操作，可以向串口打印一些信息，但是ESP8266的printf函数被封装经过了简化，不支持浮点数的格式控制符%f。IDF框架中拥有ets_printf函数可以替代封装的printf函数，这个函数在SDK中有源码，可以供我们学习和修改。这篇文章就是总结一下我自己对ESP-IDF工程中的ets_printf.c文件的修改，以实现在ESP8266系统中ets_printf对浮点数的格式控制符的支持。 一、启用ets_printf函数#使用ets_printf函数需要在工程配置里设置一下，在linux终端工程目录下输入 make menuconfig 进入工程配置页面 选择Component config选项卡 Enter进入 修改ESP8266工程宏定义配置 选择ESP8266-specific选项 Enter进入 选择 Using new ets_vprintf instead of rom code 选项 按下“空格”勾选。 最后选择 &lt; Save &gt; Enter 确认 , 然后一直选择&lt; Exit &gt;退出配置页。 至此，ets_printf.c 文件中的内容就生效，替换了原来rom中的ets_printf函数了。 二、修改ets_printf函数#官方库里提供的ets_printf函数仍然不支持浮点数的格式控制符，但是源码已经给出了，我们可以在源码基础上修改，使它支持格式控制符“%f” 浮点数的格式控制包括“f”、“0”、“.”、数字几个操作，其中“0”、“.”和数字控制符都已经在格式控制系统内了，我们只需要写“f”对应的函数，并作为分支插入格式控制处理的switch结构里就可以了。 编写的过程参照了%d的格式处理过程： 12345678case 'd': attr.value.val32 = va_arg(va, int); if (attr.value.val32 &lt; 0) { ets_putc('-'); attr.value.val32 = -attr.value.val32; } ets_printf_int(&amp;attr, 10); break; 由%d的 处理我发现需要在attr结构体里添加double型的变量，用来缓存变参数列表里的float或者double类型的变量。 原结构体类型是下面这样的： 123456typedef union _val_cache { uint8_t val8; int32_t val32; uint32_t val32u; const char *valcp;} val_cache_t; 添加double类型的变量valfloat作为浮点数的缓存变量。新结构体类型如下： 1234567typedef union _val_cache { uint8_t val8; int32_t val32; uint32_t val32u; const char *valcp; double valfloat;} val_cache_t; 接下来，我们就可以在扫描格式控制的函数里，仿照%d的格式控制方式添加%f的格式控制了 涉及到的函数是 int ets_vprintf(const char *fmt, va_list va) 在遍历扫描的switch里添加 1case 'f': 在确定了本次所有格式控制操作之后的执行将数值写入打印缓存的switch操作里添加对应的float打印操作 12345678case 'f': attr.value.valfloat = va_arg(va, double); if (attr.value.valfloat &lt; 0) { ets_putc('-'); attr.value.valfloat = -attr.value.valfloat; } ets_printf_float(&amp;attr); break; 首先获取可变参列表里的double数据，判断是否为负，并把绝对值传递给专门的float打印函数。 专门的float型数据打印处理函数ets_printf_float(&amp;attr)是我自己根据这套打印结构的特点写的，参照了int型数据的处理过程，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#define FLOAT_decimals_MAX_NUM 9#define VFLOAT_STR_MAX 20static int ets_printf_float(val_attr_t * const attr){ char buf[VFLOAT_STR_MAX]; unsigned char offset = VFLOAT_STR_MAX; int32_t integer=attr-&gt;value.valfloat; double decimals = (attr-&gt;value.valfloat-integer); if (attr-&gt;precision!=0) { for (int i =0; i&lt;attr-&gt;precision;i++) { decimals=decimals*10.0; } integer=decimals; if(decimals-integer&gt;0.5)//末位四舍五入 integer++; for (int i =0; i&lt;attr-&gt;precision;i++) { unsigned char c = integer % 10; buf[--offset] = c + '0'; integer /= 10; } } else { int i =0; for (i =0; i&lt;FLOAT_decimals_MAX_NUM;i++) { decimals=decimals*10.0; int digit=decimals; if((decimals-(digit))==0.0) { i++; break; } } integer=decimals; if(decimals-integer&gt;0.5) integer++; for (; i&gt;0;i--) { unsigned char c = integer % 10; buf[--offset] = c + '0'; integer /= 10; } } buf[--offset] = '.'; integer=attr-&gt;value.valfloat; if (integer != 0) { for (; integer &gt; 0; integer /= 10) { unsigned char c = integer % 10; buf[--offset] = c + '0'; } } else buf[--offset] = '0'; if (fill_num(attr)) { char fill_data = isfill_0(attr) ? '0' : ' '; unsigned char len = fill_num(attr) - (VFLOAT_STR_MAX - offset); unsigned char left = fill_num(attr) &gt; (VFLOAT_STR_MAX - offset) ? len : 0; if (!isfill_left(attr)) { ets_printf_ch_mutlti(fill_data, left); } ets_printf_buf(&amp;buf[offset], VFLOAT_STR_MAX - offset); if (isfill_left(attr)) { fill_data = ' '; ets_printf_ch_mutlti(fill_data, left); } } else { ets_printf_buf(&amp;buf[offset], VFLOAT_STR_MAX - offset); } return 0;} 有了这个函数就可以实现ESP8266的浮点数打印操作了。其他地方完全不用修改的。其中我设置了小数点后最大位数为9位，最大字符长度为20位，如果需要超过这个长度的数据打印，可以修改此处宏定义。（实际上double型的数据可以很长很长……） 有一点需要注意的是，格式控制符中有效数字个数包括小数点。这是和计算机中的printf格式控制保持一致的。 三、直接使用#对于不关注技术实现细节的小伙伴可以直接下载我写好的文件，直接替换掉components/esp8266/source路径下原来的ets_printf.c文件即可实现浮点数的打印。 文件在我的github上（https://github.com/gengyuchao）。 欢迎关注我的博客和github呀~ 希望能够和各路大佬一起讨论技术问题~","link":"/2020/08/09/ESP8266%E7%AC%94%E8%AE%B0_%E6%A8%A1%E6%9D%BF/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start#Create a new post#1$ hexo new \"My New Post\" More info: Writing Run server#1$ hexo server More info: Server Generate static files#1$ hexo generate More info: Generating Deploy to remote sites#1$ hexo deploy More info: Deployment","link":"/2020/08/07/hello-world/"},{"title":"博客初生小记","text":"一直以来，我都希望能够有一个自己的博客，一个能够完全由自己掌控的博客，来记录自己的兴趣和知识。但是小时候的我没有这样的能力，而长大之后又被各种各样的忙碌所侵占，没有再深入研究。今天发现了 Hexo 这样一个可以方便的搭建漂亮博客的工具，可以让我用自己的代码能力任意的发挥自己的想象，这真是太酷了。所以，今天我在这里搭建了自己的第一个小站，来实现自己曾经的愿望。 以后，我也打算在这个平台上发布自己的博客，记录自己的日常生活和学到的知识，希望感兴趣的朋友来和我多多交流呀～","link":"/2020/08/08/%E5%8D%9A%E5%AE%A2%E5%88%9D%E7%94%9F%E5%B0%8F%E8%AE%B0/"},{"title":"在 Window 系统上安装 ESP-IDF 环境的简单方法","text":"这里来介绍一下 Windows 环境下，使用 CMake 直接进行编译的方法。（不需要再下载 Mingw32 或者 ESP-IDF 工具安装器啦~）这里附带：官网说明 安装软件工具#git 安装教程python 安装教程 使用 git 下载 ESP-IDF#git clone --recursive https://github.com/espressif/esp-idf.git 安装 ESP-IDF#在 ESP-IDF 路径下 打开 cmd 命令窗口，输入：install.bat等待安装完成之后 根据提示输入 export.bat 即可在该窗口下使用 IDF 了。 编辑器#推荐配合使用 VSCode 进行编辑，在使用了 export.bat 命令添加路径的 cmd 命令窗口中输入 code . 即可打开 VScode 并且环境变量能够被继承到 VScode 编辑器中。可以直接在 VScode 的 terminal 中，在工程路径下使用 idf.py 工具进行 make、flash、clean等操作，实现 Windows 系统上的 ESP32 开发。 Bug 解决#目前发现 在 windows 环境下 VSCode 编译器中 无法正常的使用 idf.py menuconfig 菜单的上下键切换功能，也就是无法进行配置。但是这个问题有一个简单的解决方法，可以使用 start cmd命令召唤出新的 cmd 窗口，再使用 idf.py menuconfig 就可以使用方向键控制 menu 菜单了。 好啦 ESP-IDF 的简单安装方法就介绍完毕了~ 希望大家多多和我交流呀~ O(∩_∩)O哈哈~","link":"/2020/08/09/%E5%9C%A8%20Window%20%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85%20ESP-IDF%20%E7%8E%AF%E5%A2%83/"},{"title":"ESP8266开发学习笔记_浮点数打印支持","text":"① ESP8266 开发学习笔记_By_GYC 【更新 ets_printf 函数 使ESP_IDF 能够支持浮点数打印】 一、启用ets_printf函数 二、修改ets_printf函数 三、直接使用 ① ESP8266 开发学习笔记_By_GYC 【更新 ets_printf 函数 使ESP_IDF 能够支持浮点数打印】#在我们日常的开发过程中，经常使用到的一个功能就是串口打印功能。在ESP8266的IDF框架中，提供了类似控制台的printf操作，可以向串口打印一些信息，但是ESP8266的printf函数被封装经过了简化，不支持浮点数的格式控制符%f。IDF框架中拥有ets_printf函数可以替代封装的printf函数，这个函数在SDK中有源码，可以供我们学习和修改。这篇文章就是总结一下我自己对ESP-IDF工程中的ets_printf.c文件的修改，以实现在ESP8266系统中ets_printf对浮点数的格式控制符的支持。 一、启用ets_printf函数#使用ets_printf函数需要在工程配置里设置一下，在linux终端工程目录下输入 make menuconfig 进入工程配置页面 选择Component config选项卡 Enter进入 修改ESP8266工程宏定义配置 选择ESP8266-specific选项 Enter进入 选择 Using new ets_vprintf instead of rom code 选项 按下“空格”勾选。 最后选择 &lt; Save &gt; Enter 确认 , 然后一直选择&lt; Exit &gt;退出配置页。 至此，ets_printf.c 文件中的内容就生效，替换了原来rom中的ets_printf函数了。 二、修改ets_printf函数#官方库里提供的ets_printf函数仍然不支持浮点数的格式控制符，但是源码已经给出了，我们可以在源码基础上修改，使它支持格式控制符“%f” 浮点数的格式控制包括“f”、“0”、“.”、数字几个操作，其中“0”、“.”和数字控制符都已经在格式控制系统内了，我们只需要写“f”对应的函数，并作为分支插入格式控制处理的switch结构里就可以了。 编写的过程参照了%d的格式处理过程： 12345678case 'd': attr.value.val32 = va_arg(va, int); if (attr.value.val32 &lt; 0) { ets_putc('-'); attr.value.val32 = -attr.value.val32; } ets_printf_int(&amp;attr, 10); break; 由%d的 处理我发现需要在attr结构体里添加double型的变量，用来缓存变参数列表里的float或者double类型的变量。 原结构体类型是下面这样的： 123456typedef union _val_cache { uint8_t val8; int32_t val32; uint32_t val32u; const char *valcp;} val_cache_t; 添加double类型的变量valfloat作为浮点数的缓存变量。新结构体类型如下： 1234567typedef union _val_cache { uint8_t val8; int32_t val32; uint32_t val32u; const char *valcp; double valfloat;} val_cache_t; 接下来，我们就可以在扫描格式控制的函数里，仿照%d的格式控制方式添加%f的格式控制了 涉及到的函数是 int ets_vprintf(const char *fmt, va_list va) 在遍历扫描的switch里添加 1case 'f': 在确定了本次所有格式控制操作之后的执行将数值写入打印缓存的switch操作里添加对应的float打印操作 12345678case 'f': attr.value.valfloat = va_arg(va, double); if (attr.value.valfloat &lt; 0) { ets_putc('-'); attr.value.valfloat = -attr.value.valfloat; } ets_printf_float(&amp;attr); break; 首先获取可变参列表里的double数据，判断是否为负，并把绝对值传递给专门的float打印函数。 专门的float型数据打印处理函数ets_printf_float(&amp;attr)是我自己根据这套打印结构的特点写的，参照了int型数据的处理过程，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#define FLOAT_decimals_MAX_NUM 9#define VFLOAT_STR_MAX 20static int ets_printf_float(val_attr_t * const attr){ char buf[VFLOAT_STR_MAX]; unsigned char offset = VFLOAT_STR_MAX; int32_t integer=attr-&gt;value.valfloat; double decimals = (attr-&gt;value.valfloat-integer); if (attr-&gt;precision!=0) { for (int i =0; i&lt;attr-&gt;precision;i++) { decimals=decimals*10.0; } integer=decimals; if(decimals-integer&gt;0.5)//末位四舍五入 integer++; for (int i =0; i&lt;attr-&gt;precision;i++) { unsigned char c = integer % 10; buf[--offset] = c + '0'; integer /= 10; } } else { int i =0; for (i =0; i&lt;FLOAT_decimals_MAX_NUM;i++) { decimals=decimals*10.0; int digit=decimals; if((decimals-(digit))==0.0) { i++; break; } } integer=decimals; if(decimals-integer&gt;0.5) integer++; for (; i&gt;0;i--) { unsigned char c = integer % 10; buf[--offset] = c + '0'; integer /= 10; } } buf[--offset] = '.'; integer=attr-&gt;value.valfloat; if (integer != 0) { for (; integer &gt; 0; integer /= 10) { unsigned char c = integer % 10; buf[--offset] = c + '0'; } } else buf[--offset] = '0'; if (fill_num(attr)) { char fill_data = isfill_0(attr) ? '0' : ' '; unsigned char len = fill_num(attr) - (VFLOAT_STR_MAX - offset); unsigned char left = fill_num(attr) &gt; (VFLOAT_STR_MAX - offset) ? len : 0; if (!isfill_left(attr)) { ets_printf_ch_mutlti(fill_data, left); } ets_printf_buf(&amp;buf[offset], VFLOAT_STR_MAX - offset); if (isfill_left(attr)) { fill_data = ' '; ets_printf_ch_mutlti(fill_data, left); } } else { ets_printf_buf(&amp;buf[offset], VFLOAT_STR_MAX - offset); } return 0;} 有了这个函数就可以实现ESP8266的浮点数打印操作了。其他地方完全不用修改的。其中我设置了小数点后最大位数为9位，最大字符长度为20位，如果需要超过这个长度的数据打印，可以修改此处宏定义。（实际上double型的数据可以很长很长……） 有一点需要注意的是，格式控制符中有效数字个数包括小数点。这是和计算机中的printf格式控制保持一致的。 三、直接使用#对于不关注技术实现细节的小伙伴可以直接下载我写好的文件，直接替换掉components/esp8266/source路径下原来的ets_printf.c文件即可实现浮点数的打印。 文件在我的github上（https://github.com/gengyuchao）。 欢迎关注我的博客和github呀~ 希望能够和各路大佬一起讨论技术问题~","link":"/2020/08/09/ESP8266%E7%AC%94%E8%AE%B0_%E6%B5%AE%E7%82%B9%E6%95%B0%E6%89%93%E5%8D%B0%E6%94%AF%E6%8C%81/"}],"tags":[{"name":"ESP8266","slug":"ESP8266","link":"/tags/ESP8266/"},{"name":"ESP32","slug":"ESP32","link":"/tags/ESP32/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"系统安装","slug":"系统安装","link":"/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"name":"IDF","slug":"IDF","link":"/tags/IDF/"},{"name":"浮点数打印","slug":"浮点数打印","link":"/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E6%89%93%E5%8D%B0/"},{"name":"TEST","slug":"TEST","link":"/tags/TEST/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"}],"categories":[{"name":"ESP8266开发学习笔记","slug":"ESP8266开发学习笔记","link":"/categories/ESP8266%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"ESP32","slug":"ESP32","link":"/categories/ESP32/"}]}