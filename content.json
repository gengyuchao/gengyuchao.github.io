{"pages":[{"title":"","text":"宝贝 宝贝 宝贝 宝贝 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"个人简介# 分享很喜欢的**老罗**的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息# 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引# 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划#2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录#","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念# tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start#Create a new post#1$ hexo new \"My New Post\" More info: Writing Run server#1$ hexo server More info: Server Generate static files#1$ hexo generate More info: Generating Deploy to remote sites#1$ hexo deploy More info: Deployment","link":"/2020/08/07/hello-world/"},{"title":"加密测试","text":"嗨，请准确无误地输入密码查看哟！ 30f9441527159f8159e2d4625ba88cec4610fb964a4efc54c5dbbb1ffba01fa59c338013fa05bcfbec8b59b5e6a9fb2fd20da0c17f7b9795f0943b8085d614b0a52eff59008b167faf4d835269fbca055666789069c3feb377ba4e22bd86f228e2f9ddd52411c8f2f355df6aaa4b64ce4232ba58448cf9ea5c85b5a60638c7f125497845cb1750f32052820c15758bffeb3b7c01eba610e125330a179b1256e0d25b85b86610153dfff9c7d1edfededebad5998f980ec26cf463fab484306d101a5a2f31ea160007a9d58865e5ccb881da19c7d5e63a985fb5abb509d8247d1edbc038bc77bd38288ec878da40a1e3e71ac151e41a20789f921b94a7c418fdd922e3e2d11f66cf4c39b10479f573dbf443193c847b0ba43fb5e4cc10b0c4b2fca4ef8f5fc2bd431f46fd09fc413ac3946ab1716c2dd401d1172474e0a5f9334e","link":"/2020/08/09/%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95/"},{"title":"博客初生小记","text":"一直以来，我都希望能够有一个自己的博客，一个能够完全由自己掌控的博客，来记录自己的兴趣和知识。但是小时候的我没有这样的能力，而长大之后又被各种各样的忙碌所侵占，没有再深入研究。今天发现了 Hexo 这样一个可以方便的搭建漂亮博客的工具，可以让我用自己的代码能力任意的发挥自己的想象，这真是太酷了。所以，今天我在这里搭建了自己的第一个小站，来实现自己曾经的愿望。 以后，我也打算在这个平台上发布自己的博客，记录自己的日常生活和学到的知识，希望感兴趣的朋友来和我多多交流呀～","link":"/2020/08/08/%E5%8D%9A%E5%AE%A2%E5%88%9D%E7%94%9F%E5%B0%8F%E8%AE%B0/"},{"title":"Bluetooth学习笔记_模板","text":"Bluetooth学习笔记 【模板】 之前是在其他博客平台写了一些文章，现在打算移植到自己的的平台上，所以使用此模板进行复制。 一、启用ets_printf函数 一、启用ets_printf函数#欢迎关注我的博客和github呀~ 希望能够和各路大佬一起讨论技术问题~","link":"/2020/08/09/Bluetooth/Bluetooth%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A8%A1%E6%9D%BF/"},{"title":"Bluetooth学习笔记_BLE_基础知识点1","text":"Bluetooth学习笔记 【BLE 基础知识点 1】 这里是我搜集的一些关于 BLE 的基本概念 和 说明。 BLE 知识点#1、蓝牙协议栈层次# 2、BLE低功耗蓝牙核心协议层详解（Bluetooth Core）# 1、物理层（Physical Layer，简写 PHY）：PHY层用来指定BLE所用的无线频段，调制解调方式和方法等。是1Mbps自适应跳频的GFSK射频，工作于免许可证的2.4GHz ISM（工业、科学与医疗）频段。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。 2、链路层（Link Layer，简写 LL）：LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。LL层要做的事情非常多，比如具体选择哪程度 个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者ATT。 3、主机控制接口层（Host Controller Interface，简写 HCI）：HCI是可选的，HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。 4、通用访问配置文件层（Generic access profile，简写GAP）：GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。 5、逻辑链路控制及自适应协议层（Logical Link Control and Adaptation Protocol，简写 L2CAP）：L2CAP对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。 6、安全管理层（Security Manager，简写 SM）：SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。 7、属性协议层（Attribute protocol，简写 ATT）：简单来说，ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE协议栈中，开发者接触最多的就是ATT。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。 8、通用属性配置文件层（Generic Attribute profile，简写 GATT）：GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品。 3、蓝牙协议组成# 蓝牙协议体系中的协议按SIG的关注程度分为四层： （1）核心协议：BaseBand、LMP、L2CAP、SDP； （2）电缆替代协议：RFCOMM； （3）电话传送控制协议：TCS-Binary、AT命令集； （4）选用协议：PPP、UDP/TCP/IP、OBEX、WAP、vCard、vCal、IrMC、WAE。 除上述协议层外，规范还定义了主机控制器接口（HCI），它为基带控制器、连接管理器、硬件状态和控制寄存器提供命令接口。在上图中可见，HCI位于L2CAP的下层，但HCI也可位于L2CAP上层。 蓝牙核心协议由SIG制定的蓝牙专用协议组成。绝大部分蓝牙设备都需要核心协议（加上无线部分），而其他协议则根据应用的需要而定。总之，电缆替代协议、电话控制协议和被采用的协议在核心协议基础上构成了面向应用的协议。 4、蓝牙基本架构# 4.1底层硬件模块 （1）无线射频模块（Radio）：蓝牙最底层，带微带天线，负责数据接收和发送。 （2）基带模块（BaseBand）：无线介质访问约定。提供同步面向连接的物理链路（SCO）和异步无连接物理链路（ACL），负责跳频和蓝牙数据及信息帧传输，并提供不同层次的纠错功能（FEC和CTC）。 （3）链路控制模块（LC）：蓝牙数据包的编码和解码。 （4）链路管理模块（LM）：负责创建、修改和发布逻辑链接，更新设备间物理链接参数，进行链路的安全和控制。 （5）主机控制器接口（HCI）：是软硬件接口部分，由基带控制器、连接管理器、控制和事件寄存器等组成；软件接口提供了下层硬件的统一命令，解释上下层消息和数据的传递。硬件接口包含UART、SPI和USB等。 4.2.中间协议层 （1）逻辑链路控制与适配协议（L2CAP）：蓝牙协议栈的基础，也是其他协议实现的基础。向上层提供面向连接和无连接的数据封装服务；采用了多路技术、分割和重组技术、组提取技术来进行协议复用、分段和重组、认证服务质量、组管理等行为。 （2）音视频发布传输协议（AVDTP）和音视频控制传输协议（AVCTP）：二者主要用于Audio/Video在蓝牙设备中传输的协议，前者用于描述传输，后者用于控制信号交换的格式和机制。 （3）服务发现协议（SDP）：蓝牙技术框架至关重要一层，所有应用模型基础。动态的查询设备信息和服务类型，建立一条对应的服务通信通道，为上层提供发现可用的服务类型和属性协议信息。 （4）串口仿真协议（RFCOMM）：实现了仿真9针RS232串口功能，实现设备间的串行通信。 （5）二进制电话控制协议（TCS）：基于 ITU-T Q.931 建议的采用面向比特的协议，它定义了用于蓝牙设备之间建立语音和数据呼叫的控制信令（Call Control Signalling），并负责处理蓝牙设备组的移动管理过程。 4.3.蓝牙Profile Bluetooth Profile是蓝牙设备间数据通信的无线接口规范。目前有四大类、十三种协议规则，厂商可以自定义规格。几种最常见的Profile文件： （1）通用访问配置文件（GAP）：其他所有配置文件的基础，定义了在蓝牙设备间建立基带链路的通用方法，并允许开发人员根据GAP定义新的配置文件。包含所有蓝牙设备实施的功能，发现和连接设备的通用步骤，基本用户界面等通用操作。 （2）服务发现应用配置文件（SDAP）：描述应用程序如何用SDP发现远程设备服务，可与向/从其他蓝牙设备发送/接收服务查询的SDP连接。 （3）串行端口配置文件（SPP）：基于ETSI TS 07.10规格定义如何设置虚拟串行端口及如何连接两个蓝牙设备。速度可达128kb/s。 （4）通用对象交换配置文件（GOEP）：可以将任意对象（如图片、文档等）从一个设备传输到另一个设备。","link":"/2020/08/09/Bluetooth/Bluetooth%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_BLE_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B91/"},{"title":"ESP8266开发学习笔记_DHT11温湿度传感器","text":"ESP8266 开发学习笔记_By_GYC 【DHT11 温湿度传感器】 本章介绍ESP8266 IDF 框架下 如何使用GPIO口进行单总线时序模拟，介绍DHT11温湿度传感器的使用方法，实现对温湿度的采集。 一、准备材料 二、硬件连接 三、软件编程 1、修改工程名 2、添加组件 3、编程 4、反馈结果 5、核心代码 四、总结 一、准备材料#①开发板：NodeMcu （ESP8266） ②环境：Ubuntu 18.04 、 ESP-IDF 操作系统（ ESP8266_RTOS_SDK V3.2） ③传感器：DHT11 ④辅助材料：杜邦线、面包板 二、硬件连接# DHT11的硬件只包含三个引脚，分别是VCC、GND和数据输出引脚DATA。其模块输入电压VCC的输入范围是3.3V~5V。采样周期为1秒。传感器接3.3V电源、GND和ESP8266的GPIO5，信号引脚DATA接5kΩ上拉电阻，完成DHT11的硬件系统。 三、软件编程#DHT11能够使用单总线传输协议与ESP8266进行通信。其中ESP8266作为主机，DHT11作为从机。主机给传感器DHT11发送起始信号，收到从机应答信号后初始化成功，能够进行数据传输。 DHT11回复响应信号后，会发送40bit的传感器数据，包括两个字节的湿度数据（一个字节整数、一个字节小数），两个字节的温度数据整数（一个字节整数、一个字节小数），最后是一个字节的校验和数据。通过求和校验的数据将会作为最后发送的数据。 本次例程是基于EPS8266 IDF的example “project_template” 进行开发，直接在模板基础上进行新内容的添加。 1、修改工程名#首先，将MakeFile中模板中的工程名字 1PROJECT_NAME := project_template 修改为 1PROJECT_NAME := project_DHT11 2、添加组件#然后添加工程组件文件夹 dht11_driver 到自己工程的 components （组件） 下 （PS：本次首先提供C++版本的驱动，工程中C++的具体使用方法可以参考我的系列博客内容） 3、编程#修改user_main.c 为 user_main.cpp 添加 dht11驱动的头文件 “dht11_driver.hpp” 为 void app_main(void) 函数添加修饰符 extern “C” 如下： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include \"esp_system.h\" #include \"dht11_driver.hpp\" //生成 DHT11 的实例化对象DHT_Sensor my_DHT11(GPIO_NUM_5,DHT11);/****************************************************************************** * FunctionName : app_main * Description : entry of user application, init user function here * Parameters : none * Returns : none*******************************************************************************/extern \"C\" void app_main(void){ printf(\"SDK version:%s\\n\", esp_get_idf_version()); my_DHT11.DHTInit(); while(1) { my_DHT11.DHTRead(); ESP_LOGI(\"DHT11\",\"DHT: Temperature*100 = %d *C, Humidity*100 = %d %% (GPIO%d)\", (int) (my_DHT11.Sensor_Data.temperature * 100), (int) (my_DHT11.Sensor_Data.humidity * 100), my_DHT11.data_pin); vTaskDelay(1000 / portTICK_RATE_MS); }} 4、反馈结果# 5、核心代码#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//温湿度传感器数据读取（并将数据写入到传入指针） bool DHT_Sensor::DHTRead(DHT_Sensor_Data* output){ int counter = 0; int laststate = 1; int i = 0; int j = 0; int checksum = 0; int data[100]; data[0] = data[1] = data[2] = data[3] = data[4] = 0; gpio_num_t pin = (gpio_num_t)data_pin; gpio_set_direction(pin,GPIO_MODE_OUTPUT); // Wake up device, 250ms of high gpio_set_level(pin, 1); sleepms(250); // Hold low for 20ms gpio_set_level(pin, 0); sleepms(20); // High for 40ns gpio_set_level(pin, 1); delay_us(40); // Set DHT_PIN pin as an input gpio_set_direction(pin,GPIO_MODE_INPUT); //GPIO_DIS_OUTPUT(pin); // wait for pin to drop? while (gpio_get_level(pin) == 1 &amp;&amp; i &lt; DHT_MAXCOUNT) { delay_us(1); i++; } if(i == DHT_MAXCOUNT) { DHT_DEBUG(\"DHT: Failed to get reading from GPIO%d, dying\\r\\n\", pin); return false; } // read data for (i = 0; i &lt; DHT_MAXTIMINGS; i++) { // Count high time (in approx us) counter = 0; while (gpio_get_level(pin) == laststate) { counter++; delay_us(1); if (counter == 1000) break; } laststate = gpio_get_level(pin); if (counter == 1000) break; // store data after 3 reads if ((i&gt;3) &amp;&amp; (i%2 == 0)) { // shove each bit into the storage bytes data[j/8] &lt;&lt;= 1; if (counter &gt; DHT_BREAKTIME) data[j/8] |= 1; j++; } } if (j &gt;= 39) { checksum = (data[0] + data[1] + data[2] + data[3]) &amp; 0xFF; DHT_DEBUG(\"DHT%s: %02x %02x %02x %02x [%02x] CS: %02x (GPIO%d)\\r\\n\", sensor_type==DHT11?\"11\":\"22\", data[0], data[1], data[2], data[3], data[4], checksum, pin); if (data[4] == checksum) { // checksum is valid output-&gt;temperature = scale_temperature(data); output-&gt;humidity = scale_humidity(data); DHT_DEBUG(\"DHT: Temperature*100 = %d *C, Humidity*100 = %d %% (GPIO%d)\\n\", (int) (output-&gt;temperature * 100), (int) (output-&gt;humidity * 100), pin); } else { DHT_DEBUG(\"DHT: Checksum was incorrect after %d bits. Expected %d but got %d (GPIO%d)\\r\\n\", j, data[4], checksum, pin); return false; } } else { DHT_DEBUG(\"DHT: Got too few bits: %d should be at least 40 (GPIO%d)\\r\\n\", j, pin); return false; } return true;} 四、总结#驱动DHT11主要就是遵从时序图，按照时序图中规定的时序控制和读取单线的DHT11传感器数据，最终通过原始数据换算得到最终的温湿度数据的值。 本次的工程我会开源到自己的github上（https://github.com/gengyuchao），欢迎大家来和我一起交流呀。","link":"/2020/08/09/ESP8266%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP8266%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/"},{"title":"在 Window 系统上安装 ESP-IDF 环境的简单方法","text":"这里来介绍一下 Windows 环境下，使用 CMake 直接进行编译的方法。（不需要再下载 Mingw32 或者 ESP-IDF 工具安装器啦~）这里附带：官网说明 安装软件工具 使用 git 下载 ESP-IDF 安装 ESP-IDF 编辑器 Bug 解决 安装软件工具#git 安装教程python 安装教程 使用 git 下载 ESP-IDF#git clone --recursive https://github.com/espressif/esp-idf.git 安装 ESP-IDF#在 ESP-IDF 路径下 打开 cmd 命令窗口，输入：install.bat等待安装完成之后 根据提示输入 export.bat 即可在该窗口下使用 IDF 了。 编辑器#推荐配合使用 VSCode 进行编辑，在使用了 export.bat 命令添加路径的 cmd 命令窗口中输入 code . 即可打开 VScode 并且环境变量能够被继承到 VScode 编辑器中。可以直接在 VScode 的 terminal 中，在工程路径下使用 idf.py 工具进行 make、flash、clean等操作，实现 Windows 系统上的 ESP32 开发。 Bug 解决#目前发现 在 windows 环境下 VSCode 编译器中 无法正常的使用 idf.py menuconfig 菜单的上下键切换功能，也就是无法进行配置。但是这个问题有一个简单的解决方法，可以使用 start cmd命令召唤出新的 cmd 窗口，再使用 idf.py menuconfig 就可以使用方向键控制 menu 菜单了。 好啦 ESP-IDF 的简单安装方法就介绍完毕了~ 希望大家多多和我交流呀~ O(∩_∩)O哈哈~","link":"/2020/08/09/ESP32%E5%AD%A6%E4%B9%A0/%E5%9C%A8%20Window%20%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85%20ESP-IDF%20%E7%8E%AF%E5%A2%83/"},{"title":"ESP8266开发学习笔记_OLED屏幕的IIC驱动","text":"ESP8266 开发学习笔记_By_GYC 【OLED屏幕的IIC驱动】 在我之前的文章中简单介绍过oled的IIC驱动程序，包括SSD1306芯片手册的一些内容，并参考了Arduino大神的代码，将OLED在Arduino上的的驱动改写为了能够应用于ESP8266 RTOS SDK的C语言版本，并作为我的常用库使用。在发现ESP8266可以使用C++编程之后我决定将 ThingPulse 的OLED驱动库（c++版本）完整的进行移植，让我能够在SDK中也能够方便的使用。 最近我也在研究应用在stm32单片机的FreeRtos操作系统，所以本次OLED的驱动也考虑了在其他FreeRtos操作系统中的适配，可以方便的通过宏定义配置的方式，直接应用在支持FreeRtos操作系统的单片机上。 （目前库中仅支持ESP8266 IDF版本和STM32F103 FreeRTOS及 STM32F103 无操作系统版本。 如果使用其他系列单片机 通信协议还是需要自己修改的）。 适用范围 适用范围#|—||ESP8266_RTOS_SDK V3.0 （ESP-IDF Style）||STM32F103裸机||STM32F103 FreeRtos操作系统版本| user_config 用户配置使用宏定义在“user_oled_config.h”中使用不同的使用方式 12345#define ESP8266_IDF // ESP-IDF支持 （默认启用FreeRtos支持）#define STM32F103 // Stm32支持#define USE_FreeRTOS // FreeRTOS支持 如果您不使用FreeRTOS操作系统，则需要自己覆盖millis（）函数。 I2C使用方法使用IIC方式驱动OLED屏幕的方式 123#include \"SSD1306I2C.hpp\"SSD1306I2C display(ADDRESS, SCL, SDA); 对于 esp8266-idf 1SSD1306I2C display(0x3c,GPIO_NUM_5,GPIO_NUM_4);// OLED_Address SCL SDA 对于 stm32 1SSD1306I2C display(0x3c, GPIO_Pin_10, GPIO_Pin_11); //OLED_Address SCL SDA API接口 显示控制 12345678910111213141516171819202122232425262728293031323334353637383940414243//初始化显示void init（）;//释放显示器使用的内存void end（）;//循环初始化void resetDisplay（void）;//再次通过I2C连接到显示器void reconnect（void）;//打开显示屏void displayOn（void）;//关闭显示屏void displayOff（void）;//清除本地像素缓冲区void clear（void）;//将缓冲区写入显示内存void display（void）;//倒置显示模式void invertDisplay（void）;//正常显示模式void normalDisplay（void）;//设置显示对比度//真正的低亮度和对比度：对比度= 10，预充电= 5，comdetect = 0//正常亮度和对比度：对比度= 100void setContrast（uint8_t contrast，uint8_t precharge = 241，uint8_t comdetect = 64）;//访问的便捷方法void setBrightness（uint8_t）;//翻转显示屏void flipScreenVertically（）;//绘制镜像的屏幕void mirrorScreen（）; 像素绘图 12345678910111213141516171819202122232425262728293031323334353637/ *绘图功能* ///设置所有像素操作的颜色void setColor（OLEDDISPLAY_COLOR color）;//在给定位置绘制一个像素void setPixel（int16_t x，int16_t y）;//从位置0到位置1绘制一条线void drawLine（int16_t x0，int16_t y0，int16_t x1，int16_t y1）;//在给定位置绘制矩形的边框void drawRect（int16_t x，int16_t y，int16_t width，int16_t height）;//填充矩形void fillRect（int16_t x，int16_t y，int16_t width，int16_t height）;//绘制圆的边框void drawCircle（int16_t x，int16_t y，int16_t radius）;//填圈void fillCircle（int16_t x，int16_t y，int16_t radius）;//水平画一条线void drawHorizo​​ntalLine（int16_t x，int16_t y，int16_t length）;//垂直画一个林void drawVerticalLine（int16_t x，int16_t y，int16_t length）;//绘制一个圆形进度条，其外部尺寸由宽度和高度给定。进步是// 0到100之间的无符号字节值void drawProgressBar（uint16_t x，uint16_t y，uint16_t width，uint16_t height，uint8_t progress）;//以内部图像格式绘制位图void drawFastImage（int16_t x，int16_t y，int16_t width，int16_t height，const uint8_t * image）;//画一个XBMvoid drawXbm（int16_t x，int16_t y，int16_t width，int16_t height，const char * xbm）; 文字操作 1234567891011121314151617181920212223void drawString（int16_t x，int16_t y，String text）;//在给定位置绘制一个最大宽度的字符串。//如果给定的String宽于指定的宽度//文本将被包装到空格或短划线的下一行void drawStringMaxWidth（int16_t x，int16_t y，int16_t maxLineWidth，String text）;//返回带有当前值的const char *的宽度//字体设置uint16_t getStringWidth（const char * text，uint16_t length）;// const char版本的Convencience方法uint16_t getStringWidth（String text）;//指定相对于哪个锚点//文字被渲染。可用常数：// TEXT_ALIGN_LEFT，TEXT_ALIGN_CENTER，TEXT_ALIGN_RIGHT，TEXT_ALIGN_CENTER_BOTHvoid setTextAlignment（OLEDDISPLAY_TEXT_ALIGNMENT textAlignment）;//设置当前字体。可用的默认字体// ArialMT_Plain_10，ArialMT_Plain_16，ArialMT_Plain_24//或者使用http://oleddisplay.squix.ch上的字体工具创建一个void setFont（const uint8_t * fontData）; 由于这个库本身是由 ThingPulse 开发而来，我再此就不做过多的说明，功能研究请移步 ThingPulse 网站，我仅将移植好的原代码放在我的github仓库中（https://github.com/gengyuchao/oled_ssd1306） 如果有需要可以自己下载研究，有任何问题欢迎与我交流讨论。我会把以后遇到的问题在博客中进行补充说明。","link":"/2020/08/09/ESP8266%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP8266%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_OLED%E5%B1%8F%E5%B9%95%E7%9A%84IIC%E9%A9%B1%E5%8A%A8/"},{"title":"ESP8266开发学习笔记_Ubuntu系统安装","text":"ESP8266 开发学习笔记_By_GYC 【虚拟机Ubuntu系统的安装】 本来是想最后有时间再写这篇博客的，奈何皂滑弄人，昨天晚上在写上一篇还未出世的博客文章的时候，手滑更新了一下ubuntu系统，再加之前几天更新了主机的显卡驱动，我的Ubuntu虚拟机挂了，驱动不兼容在无法加载登陆界面。虽然通过一些骚操作能够进入桌面系统，但已经不是最好的Linux体验了，所以打算重新安装最新版本的Ubuntu系统，重新搭建一下开发环境。正好填一下自己留的坑，记录一下这次虚拟机Ubuntu系统搭建的过程。 一、获取最新稳定版本的Ubuntu系统安装包。 二、软件安装 1、默认软件 2、安装VM Tools 3、切换软件安装源 4、代码编辑器 VSCode 5、git 6、其他软件 三、接下来 一、获取最新稳定版本的Ubuntu系统安装包。#百度Ubuntu 第一个条目就是Ubuntu系统的官方下载 选择稳定版本的Download 等待迅雷下载完成 打开VM虚拟机-&gt;创建一个新的虚拟机 选择典型虚拟机 使用光盘镜像安装 文件定位到我们刚刚下载的Ubuntu安装包（*.iso文件） 给你的系统起个名字 填入自己想要的用户名和密码 因为我可能会存比较多的文件，Linux磁盘大小设置为40G ，拆分为多个文件 根据自己的电脑情况，自定义一下硬件： 最后点击完成，等待简易安装自动完成 就可以了。 二、软件安装 #1、默认软件#安装好后系统会推荐你安装一些软件，你可以根据自己的需要或者兴趣点击进行安装。 2、安装VM Tools#因为是在VM虚拟机中，所以需要安装VM Tools，方便虚拟机和主机文件互传等操作。 emmmm 我一不留神，VM Tools自己装好了，如果你的虚拟机没有帮你完成，可以在虚拟机选项卡上右击手动选择安装VMware Tools。 3、切换软件安装源# 因为国外网络访问速度问题，推荐大家切换最适合自己的软件安装镜像，ubuntu系统中就直接提供了这些功能，我们可以很快的通过图形界面进行切换，切换合适的镜像之后，下载速度基本可以达到满速。 常用命令 123sudo apt-get updatesudo apt upgrade 4、代码编辑器 VSCode#只需要在终端中敲入一行代码 sudo snap install code –classic 5、git#要给系统安装git，使用如下命令，方便后续和github连接获取仓库中的文件 sudo apt install git 6、其他软件#遇到再更新。 至此我们就在windows系统下安装完成了Ubuntu版本的Linux环境了。 三、接下来#接下来我会再Ubuntu系统上安装ESP8266的交叉工具链，配置ESP-IDF开发环境。在下一篇博文中单独列出。","link":"/2020/08/09/ESP8266%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP8266%E7%AC%94%E8%AE%B0_Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"title":"ESP8266开发学习笔记_使用C++进行嵌入式编程","text":"ESP8266 开发学习笔记_By_GYC 【使用C++进行嵌入式编程】 由于C++具有封装、继承与多态的优秀特性，所以我将很多项目封装成了类方便调用，本部分会简单介绍一下如何在ESP8266中使用C++进行编程和一些注意事项。 一、简单的开始 二、主函数文件使用C++编程 extern “C”的含义就是告诉编译器，下面的函数使用C风格来编译，C语言编译时就不会修改函数名，因为没有重载，类，命名空间等这些概念，函数名是唯一的，而C++因为有类、命名空间、函数重载这些概念，所以函数名可能是相同的，所以C++编译器会修改函数名，使得两个相同函数名的函数在调用时不会产生冲突。 三、为什么使用C++ 一、简单的开始#我们使用的交叉编译工具链本身就支持C++，而且在官方的makefile里也写了C++编译相关的支持，所以对于用户来说，使用C++语言对ESP8266进行编程相当的容易，只需要将源文件的后缀改为“*.cpp” 、头文件改为 “*.hpp” ,或者直接添加“*.cpp” 、 “*.hpp”文件就可以实现使用C++语言编程。 二、主函数文件使用C++编程#同样的原理，在main文件夹下，将user_main.c 改为 user_main.cpp 。文件中就可以使用C++的各种关键字和语法了。 不过在user_main文件中，仅仅是支持C++编译还是不够的。因为编译器需要找到app_main这个函数作为用户程序入口。直接编译会报错找不到app_main函数。 基于此情况，我们需要给 app_main 函数加上 extern “C” 来告诉编译器，这个函数使用C语言风格编译，启动程序就能够正常的找到用户程序的入口了。 问题产生的原因和解决的原理如下： 此部分引用 作者：obatmg 的描述，详细原文链接为：https://blog.csdn.net/u014783685/article/details/84973067 C++编译器在将cpp文件编译成库时，导出的函数名会改变，成员函数会通过加一些元素变成全局函数，如果这时候我们需要用C语言调用C++的函数，就会遇到C语言程序无法根据用户提供的函数名寻找到C++库中导出的真实函数名的问题，C++库中导出的真实函数名是由编译器决定的，这个时候就需要用到extern关键字。 extern “C”的含义就是告诉编译器，下面的函数使用C风格来编译，C语言编译时就不会修改函数名，因为没有重载，类，命名空间等这些概念，函数名是唯一的，而C++因为有类、命名空间、函数重载这些概念，所以函数名可能是相同的，所以C++编译器会修改函数名，使得两个相同函数名的函数在调用时不会产生冲突。——————— 使用 extern “C” 来告诉编译器 之后，我们就可以正常的进行编译和使用了。 三、为什么使用C++#使用C++具有封装、继承与多态的优秀特性，我可以将很多项目封装成类，做成各种通用接口，方便在其他项目中调用。 使用C++类的概念，我可以构建各种子模块，通过添加类的方式添加新的功能，实现快速高灵活性的开发。 后面介绍的一些项目中也常常用到C++语言，所以在这里先做一个总结和说明，来记录和介绍我在ESP8266 IDF框架中使用C++的方法。我自己开发的小项目会上传到 我的github仓库上（https://github.com/gengyuchao），欢迎大家关注我的博客和github。如果有任何意见和建议，希望大家多多和我交流呀O(∩_∩)O~","link":"/2020/08/09/ESP8266%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP8266%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E4%BD%BF%E7%94%A8C++%E8%BF%9B%E8%A1%8C%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"title":"ESP8266开发学习笔记_XXXX","text":"ESP8266 开发学习笔记_By_GYC 【模板】#之前是在其他博客平台写了一些文章，现在打算移植到自己的的平台上，所以使用此模板进行复制。 一、启用ets_printf函数 一、启用ets_printf函数#欢迎关注我的博客和github呀~ 希望能够和各路大佬一起讨论技术问题~","link":"/2020/08/09/ESP8266%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP8266%E7%AC%94%E8%AE%B0_%E6%A8%A1%E6%9D%BF/"},{"title":"IT各职位-中英文对照","text":"中英文缩写对照 IT各职位中英文对照如下：#123456789101112131415161718191、FE – Front End 前端工程师2、BE – Back End 后端工程师3、OP – Operation 运维工程师4、TS – Technology Support 技术支持5、UI – User Interface 用户界面设计师6、QA – Quality Assurance 测试工程师7、DBA – Database Administrator 数据库8、PM – Product &amp; Marketing 产品经理9、UE(UX) – User Experience 用户体验设计师10、UER – User Experience Research 用户研究","link":"/2020/08/09/English/IT%E5%90%84%E8%81%8C%E4%BD%8D-%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/"},{"title":"Qt 中无法使用搜狗输入法解决方法","text":"解决Qt中无法使用搜狗输入法的方法 在 Ubuntu 系统中使用 Qt 发现有的系统无法使用搜狗等中文输入法，该方法用于解决搜狗输入法不能在 Qt 等软件中使用的问题。（题外话：Ubuntu 19 的 VS Code 软件不能使用搜狗输入法是 Ubuntu 软件商店安装包的问题，只能从 VS Code 官网重新下载安装解决。） 步骤 1. 编译 fcitx-qt5 源码 2. 拷贝 so 文件 3. 添加额外的环境变量 遇到的问题 1. 安装CMake失败 2. CMake 错误 3. 安装 extra-cmake-modules-1.4.0 失败 4. 缺少 xkbcommon 包 步骤#1. 编译 fcitx-qt5 源码#1.1 编译 fcitx-qt 需要 cmake，安装 cmake 命令，如果已经安装，请略过;#1sudo apt-get install cmake 1.2 安装 fcitx-libs-dev;#1sudo apt-get install fcitx-libs-dev 1.3 设置qmake的环境变量，这一步很重要且环境变量的值因人而异# 1.3.1. 首先确定你的Qt的安装目录，我这里是~/software/Qt5.6.0/，你的或者可能在/home/&lt;用户名&gt;/Qt5.6.0/ 1.3.2. export PATH=&quot;/5.6/gcc_64/bin&quot;:$PATH 1.4 下载fcitx-libs 源码# 1.4.1 原文的 git clone git@github.com:fcitx/fcitx-qt5.git 不可行，需要修改为https://github.com/fcitx/fcitx-qt5 1.4.2. git clone https://github.com/fcitx/fcitx-qt5 1.5 编译 fcitx-qt5#1234cd fcitx-qt5cmake .make sudo make install 2. 拷贝 so 文件#2.1找到文件#编译完成后，需要把编译得到的 libfcitxplatforminputcontextplugin.so 拷贝到 Qt5.5 安装目录的 Tools/QtCreator/bin/plugins/platforminputcontexts 或 Qt5.6 安装目录的 Tools/QtCreator/lib/Qt/plugins/platforminputcontexts，注意：两个目录根据你的Qt版本而定，Qt安装目录因人而异。 2.2复制：#Qt 5.5：cp platforminputcontext/libfcitxplatforminputcontextplugin.so /Tools/QtCreator/bin/plugins/platforminputcontextsQt 5.6：cp platforminputcontext/libfcitxplatforminputcontextplugin.so /Tools/QtCreator/lib/Qt/plugins/platforminputcontexts我这里是：cp platforminputcontext/libfcitxplatforminputcontextplugin.so ~/software/Qt5.6.0/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts 3. 添加额外的环境变量#12echo 'export XMODIFIERS=@im=fcitx' &gt;&gt; .bashrc echo 'export QT_IM_MODULE=fcitx' &gt;&gt; .bashrc 大功告成！ 遇到的问题#说明：本人系统为 Ubuntu 16.04 LTS 英文版 ，遇到的问题基本和原文一样 1. 安装CMake失败#问题描述：sudo apt-get install cmake 执行到 92 % 时提示下载失败，原因是找不到 IP 地址。问题解决：觉得应该是安装包源的问题，于是修改了系统默认的源。 123System Settings -&gt; Software &amp; Updates -&gt; Ubuntu Software -&gt; Download from 从原来的 China 改为 Main server，最后再sudo apt-get updatesudo apt-get install cmake 2. CMake 错误#问题描述： 123456789CMake Error at CMakeLists.txt:8 (find_package):Could not find a package configuration file provided by &quot;ECM&quot; (requested version 1.4.0) with any of the following names: ECMConfig.cmake ecm-config.cmake Add the installation prefix of &quot;ECM&quot; to CMAKE_PREFIX_PATH or set &quot;ECM_DIR&quot; to a directory containing one of the above files. If &quot;ECM&quot; provides a separate development package or SDK, be sure it has been installed.-- Configuring incomplete, errors occurred! 解决方法：2.1. 到这个页面 https://launchpad.net/ubuntu/+source/extra-cmake-modules/1.4.0-0ubuntu1 下载 extra-cmake-modules_1.4.0.orig.tar.xz2.2. 解压后编译安装 1234cd extra-cmake-modules-1.4.0cmake .makesudo make install 3. 安装 extra-cmake-modules-1.4.0 失败#问题描述： 123456789101112131415$:~/Downloads/extra-cmake-modules-1.4.0$ cmake .CMake Warning at tests/CMakeLists.txt:28 (find_package): Could not find a package configuration file provided by &quot;Qt5LinguistTools&quot; with any of the following names: Qt5LinguistToolsConfig.cmake qt5linguisttools-config.cmake Add the installation prefix of &quot;Qt5LinguistTools&quot; to CMAKE_PREFIX_PATH or set &quot;Qt5LinguistTools_DIR&quot; to a directory containing one of the above files. If &quot;Qt5LinguistTools&quot; provides a separate development package or SDK, be sure it has been installed.-- Looking for Sphinx Documentation Builder...-- Sphinx Documentation Builder not found - documentation will not be built (see http://sphinx-doc.org/)-- Configuring done-- Generating done-- Build files have been written to: /home/cposture/Downloads/extra-cmake-modules-1.4.0 解决方法：设置 CMAKE_PREFIX_PATH 环境变量 为 qtbase 目录（&lt;Qt安装目录&gt;/5.6/Src/qtbase/），我这里为：export CMAKE_PREFIX_PATH=”~/software/Qt5.6.0/5.6/Src/qtbase/“如果还是不行，则修改为 1export CMAKE_PREFIX_PATH=&quot;/home/cposture/software/Qt5.6.0/5.6/gcc_64/lib/cmake/&quot; 4. 缺少 xkbcommon 包#问题描述： 1234 -- Found PkgConfig: /usr/bin/pkg-config (found version &quot;0.26&quot;) -- Could NOT find XKBCommon_XKBCommon (missing: XKBCommon_XKBCommon_LIBRARY XKBCommon_XKBCommon_INCLUDE_DIR) CMake Error at /usr/share/cmake-2.8/Modules/FindPackageHandleStandardArgs.cmake:108 (message): Could NOT find XKBCommon (missing: XKBCommon_LIBRARIES XKBCommon) (Required is at least version &quot;0.5.0&quot;) 解决方法：2.1. 到 http://xkbcommon.org/ 下载最新版的 xkbcommon2.2. 解压后， 1234sudo apt-get install bison./configure --prefix=/usr --libdir=/usr/lib/x86_64-linux-gnu --disable-x11makesudo make install","link":"/2020/08/09/Ubuntu%E7%B3%BB%E7%BB%9F/Qt%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E8%A7%A3%E5%86%B3/"},{"title":"ESP8266开发学习笔记_浮点数打印支持","text":"ESP8266 开发学习笔记_By_GYC 【更新 ets_printf 函数 使ESP_IDF 能够支持浮点数打印】 在我们日常的开发过程中，经常使用到的一个功能就是串口打印功能。在ESP8266的IDF框架中，提供了类似控制台的printf操作，可以向串口打印一些信息，但是ESP8266的printf函数被封装经过了简化，不支持浮点数的格式控制符%f。IDF框架中拥有ets_printf函数可以替代封装的printf函数，这个函数在SDK中有源码，可以供我们学习和修改。这篇文章就是总结一下我自己对ESP-IDF工程中的ets_printf.c文件的修改，以实现在ESP8266系统中ets_printf对浮点数的格式控制符的支持。 一、启用ets_printf函数 二、修改ets_printf函数 三、直接使用 一、启用ets_printf函数#使用ets_printf函数需要在工程配置里设置一下，在linux终端工程目录下输入 make menuconfig 进入工程配置页面 选择Component config选项卡 Enter进入 修改ESP8266工程宏定义配置 选择ESP8266-specific选项 Enter进入 选择 Using new ets_vprintf instead of rom code 选项 按下“空格”勾选。 最后选择 &lt; Save &gt; Enter 确认 , 然后一直选择&lt; Exit &gt;退出配置页。 至此，ets_printf.c 文件中的内容就生效，替换了原来rom中的ets_printf函数了。 二、修改ets_printf函数#官方库里提供的ets_printf函数仍然不支持浮点数的格式控制符，但是源码已经给出了，我们可以在源码基础上修改，使它支持格式控制符“%f” 浮点数的格式控制包括“f”、“0”、“.”、数字几个操作，其中“0”、“.”和数字控制符都已经在格式控制系统内了，我们只需要写“f”对应的函数，并作为分支插入格式控制处理的switch结构里就可以了。 编写的过程参照了%d的格式处理过程： 12345678case 'd': attr.value.val32 = va_arg(va, int); if (attr.value.val32 &lt; 0) { ets_putc('-'); attr.value.val32 = -attr.value.val32; } ets_printf_int(&amp;attr, 10); break; 由%d的 处理我发现需要在attr结构体里添加double型的变量，用来缓存变参数列表里的float或者double类型的变量。 原结构体类型是下面这样的： 123456typedef union _val_cache { uint8_t val8; int32_t val32; uint32_t val32u; const char *valcp;} val_cache_t; 添加double类型的变量valfloat作为浮点数的缓存变量。新结构体类型如下： 1234567typedef union _val_cache { uint8_t val8; int32_t val32; uint32_t val32u; const char *valcp; double valfloat;} val_cache_t; 接下来，我们就可以在扫描格式控制的函数里，仿照%d的格式控制方式添加%f的格式控制了 涉及到的函数是 int ets_vprintf(const char *fmt, va_list va) 在遍历扫描的switch里添加 1case 'f': 在确定了本次所有格式控制操作之后的执行将数值写入打印缓存的switch操作里添加对应的float打印操作 12345678case 'f': attr.value.valfloat = va_arg(va, double); if (attr.value.valfloat &lt; 0) { ets_putc('-'); attr.value.valfloat = -attr.value.valfloat; } ets_printf_float(&amp;attr); break; 首先获取可变参列表里的double数据，判断是否为负，并把绝对值传递给专门的float打印函数。 专门的float型数据打印处理函数ets_printf_float(&amp;attr)是我自己根据这套打印结构的特点写的，参照了int型数据的处理过程，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#define FLOAT_decimals_MAX_NUM 9#define VFLOAT_STR_MAX 20static int ets_printf_float(val_attr_t * const attr){ char buf[VFLOAT_STR_MAX]; unsigned char offset = VFLOAT_STR_MAX; int32_t integer=attr-&gt;value.valfloat; double decimals = (attr-&gt;value.valfloat-integer); if (attr-&gt;precision!=0) { for (int i =0; i&lt;attr-&gt;precision;i++) { decimals=decimals*10.0; } integer=decimals; if(decimals-integer&gt;0.5)//末位四舍五入 integer++; for (int i =0; i&lt;attr-&gt;precision;i++) { unsigned char c = integer % 10; buf[--offset] = c + '0'; integer /= 10; } } else { int i =0; for (i =0; i&lt;FLOAT_decimals_MAX_NUM;i++) { decimals=decimals*10.0; int digit=decimals; if((decimals-(digit))==0.0) { i++; break; } } integer=decimals; if(decimals-integer&gt;0.5) integer++; for (; i&gt;0;i--) { unsigned char c = integer % 10; buf[--offset] = c + '0'; integer /= 10; } } buf[--offset] = '.'; integer=attr-&gt;value.valfloat; if (integer != 0) { for (; integer &gt; 0; integer /= 10) { unsigned char c = integer % 10; buf[--offset] = c + '0'; } } else buf[--offset] = '0'; if (fill_num(attr)) { char fill_data = isfill_0(attr) ? '0' : ' '; unsigned char len = fill_num(attr) - (VFLOAT_STR_MAX - offset); unsigned char left = fill_num(attr) &gt; (VFLOAT_STR_MAX - offset) ? len : 0; if (!isfill_left(attr)) { ets_printf_ch_mutlti(fill_data, left); } ets_printf_buf(&amp;buf[offset], VFLOAT_STR_MAX - offset); if (isfill_left(attr)) { fill_data = ' '; ets_printf_ch_mutlti(fill_data, left); } } else { ets_printf_buf(&amp;buf[offset], VFLOAT_STR_MAX - offset); } return 0;} 有了这个函数就可以实现ESP8266的浮点数打印操作了。其他地方完全不用修改的。其中我设置了小数点后最大位数为9位，最大字符长度为20位，如果需要超过这个长度的数据打印，可以修改此处宏定义。（实际上double型的数据可以很长很长……） 有一点需要注意的是，格式控制符中有效数字个数包括小数点。这是和计算机中的printf格式控制保持一致的。 三、直接使用#对于不关注技术实现细节的小伙伴可以直接下载我写好的文件，直接替换掉components/esp8266/source路径下原来的ets_printf.c文件即可实现浮点数的打印。 文件在我的github上（https://github.com/gengyuchao）。 欢迎关注我的博客和github呀~ 希望能够和各路大佬一起讨论技术问题~","link":"/2020/08/09/ESP8266%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP8266%E7%AC%94%E8%AE%B0_%E6%B5%AE%E7%82%B9%E6%95%B0%E6%89%93%E5%8D%B0%E6%94%AF%E6%8C%81/"},{"title":"系统使用技巧","text":"嗨，请准确无误地输入密码查看哟！ 078fcfbfe5fb385a3d8c67f2751be0801e06d1299cfbd29d7049be2e57579c07bcc54bd9af0435acbbc0f972ca940c013758150b246fa45f78424b53add2dedfba4f47d3678ec688a93f40a4084694ae35654bf22c4f75b7eee88911b39fa0166418e536145585c1e3dd5ef4b5ed74e35592fd2394ca1f52d6b6cadf8a662801831fd504465fc75e9593f17a1b4fecca1b972e0f81dce67baa21e4573d02a0b165218edbf2de216e3c30e59f76917a0c26f4328052555cdc5bac4043c6f840d9ef5b014d9329dfee1fffee996ec90f4a648a65eb37e2b2284aba63c2977fa540506f88fc87fe37a145d37bb128ddf008e367fb00bc8a10144e8235d6c609b2bc1f046e7654d63df1bde3814a6a4604acc9eee0eb38293473eedb05d4f4c7002b4af22a5fdc730cbf99e2cf4cd9715aa96aa5dc650304b6b6fc7b874816a66e668e44df66c2b8dd477fa5eb51bbc547c6e546077afe37f49a93dd5beea84f105be8821a211b0fdf6976642a988b6e207d904ad203f3e6a92f753cda3f63d7479ec7065bccca4ee00665f86afcb5122867c53ab642b588655b8af640c7de68e9abd8a40ff758303d6e6da1287016dab61a92f9e3d92e4779b2454322fccfa7729c3b4a768eed7de04f46765327bfd6367097b2dd4e739b501cb2ea03b3a2224b2c382f4e83680c7b1d677d017bb5932d5ec33de657d05bd88174900752dbcba995739b713b4f1e36244b4ba6084416b58ac61e27c0eb5bd826864d3a2ad1ffebd9d408c79394d79df69bd88328f7315db5fadd1ed56fca50980390ef569bfaf334628854a7683ebcaad0bdbcde129cb4c5efce7ba7635f94a6b9ad1dc017f9ad66702646870c5b454f977c39c14c8745fb00e8c31da5357980ef51e855a65af91471be0958808aa0a7c8b8fb0f2482fe361784eb0a1fff38197c494ee38473722e6a20b65f34908725522d80a015eb91c6db3dd14fa5a1b58c16f4a2c48414111b34bdc528635a60650965abb54361b158d151a915959b1d187060b5f52bc21d61cc61ee70d0acc8732855f2606f1c8d731899140eecf5812c5b0bf0bda5db51d4b2ce9f9af0eb17d894d29b4395cdf1bec8941377a28d01b795f7f22116594e4351722eb093db41cf0d09fc7ab83e6c615bed7ba11324117784006bba1842cc603f71998868e47d5a9e2938fcacbddcdc8151806381166eff5a7dbc7d41342a9e6979bc0e456887d2608c1c4a75791a2b5c07da024a41ff763269c89bfb04f5779dc3c0188a032d76a1f9ac04ffed98483bba5d288c4641c0f761d1a6de78528c9b7e64d9f28aaff77e44e17dfc928539271ff989f20439167810b741f7a6015e004eda988b4d15fa0d705ec5a519bcd86ffc97ff2ba45373573f52939af7ed020a2b7e754c55f69fe037bcf04d661b02815a3ddd8c6d3d6df6ab0dab0d9ba65176e85e7f9bab77dca482bb910b072d0a68f7f737158ae479a1543248a7f7a997829c38656f157a456d1d57a4542ece0a536e58f09cb46bfd0dd365e06b890989198304cacdd5766a69bf6672d37273c201128ce2d4e1e471dabf3a31da86661120202371ae1bea6c24122e2a2c06ffafc4b93ea469e96311d8ee33437b573481c7b099d4ae392119d191d74e44d813f35d66085514a58eb5a11a922511c5c93ce3edd5990d4c8782e46d8e567e3663b74de1674d5720b1ecebe3542970d0df7c0c08f68633f29b8aba3ac24484539320ee46b75dd6e54f82650f2158b5d88dad9264b324458747aad158db59e321f6f75999fdced7214a8f76ce1856cae4a3bba3baf32507ae1315fb14777050446f2fa29de9e472d0efb5eec78a0c4d20e02350fbfd2e39447b21f6fce853acc8dd9b8c149e59c105dced97bec0e442d4b967db7cb8d10e6b90906614e208a08e1a3e0a125e6ad92a59d0d4aa0ea59117688e765362733df8abfaf857fea97924f0986f71654dee38d3c3fbae65347afa055e2d7908b63cac6bcbc8d6e41e493d288b936c8e54f93187a8f06689069a23cab0fd36f66d1dd39a34e5991f7b2c6db8845aa7d5b429a705eeba8b4ad21f554fdef7bd58ac48ebfb0ac8fc7f5231788c12fcc5de226e283f234b65c3ea2bf0c2932e5f8ea24f05da37888a78401c3166e9d73bfa64d1e4b7aafae2437c642a77b439c9dc2d000471a6d527ef2104a57f0f7587af4a0140a741e42ef3f42556ebd325737f770d18663c8e591cff84ffe722ce22b260debc38a205565396ad6e52e8de690f36914b709146367d033efaf30bd04840c27044dba84fa9c652155e8bdaf7ea93f952b5cd53e98908bb4ff75e089314b934ba08e9e73576ac93c769371bf1420dfece64528007bcccb0ab9469d523f0bdac20c5128ef31e32701446a4fd6d27525065c99c3dd5bfe61b4bfd74cd09f3716396762277449ad2f0173b49bcb23d973fb95ad79510582786df1a4d99fe653595121bdd50ea77d4d6130db6c2f2120ada846a18e84c970db965d2ab3d99d8e63f7ce54583b79704ddce8490f0613a6045da566a507bde3569e55d3ca58f429407e1935d1dd39fa36cc786a6a4795700912092a7a0f838372014ebb27d4dc9e7ddf0ec2f0cf156f9adf19b478b44fd0dbf42d03777a1ea51bea9f672342b40b384d535d63391687991f0b6eb19ca6e7c187e5f85b362f6435676885291559ab9a3fcf37663cd8037415ccac6a33be5669993de22c22be60769e4cc82d0a136befcbf9afc4edb74059ceb5ee911bd546bfad9dd14e273f70d179d205569283dad48922d9eeca3341be1ce0489ddc138e2a57c004094a222df030ed9380ddac76d94ca0dba78a4b932a05e35d71ab502a820c68b40a0d4d7c937e691fc7e97b855fb84da17d362b5ccacbc257d84563efd6214bbfdef465f2185f19e863809ef6c7fceba4dec095440800bca63633f4ea8d71afce1911253ada991912df711be6654dcd686a8f5cbf20f6e48b6c932d42509af18ec6aef853998bda68338ca78246dcb4f9498803264fe71c9fd556e089bbaf83269d379ad227dd0bc187118ccfe7f455ebbb1713ff6ebec33eafb039f41430ccfcc4804acda974252f943c9c4c0d4fd20371c5bda64ec94f824abb6244f6c265d0247b67c5e43c773b24e2014a9bce95b7b242b2042b9b00aa95e82eab9a16bef68a6a31fe9707b795410fc402cf1d31741efcc5e2141a64af5bfde9a48cacc54de9e096a6cdb1771771660448325dd0add017cb8b969cc02c262296a47b833d6667edea6af205019510efdacfb1a38338adb24fb25d40c5a46b96dc9362f1d1f30ccf167d238c17f3b4163d5ca0b58a6f8b3d84abba7977174a9bd48d6b8bad11e3a6008f788937137ffc21c3a95b959bf8963f0ec7a72fee39a1f2dc195bd27376fb37f37c30f7c8ac0e6cda2e1178b9cd103a53c651b14e1573cc09e31a31c8e704df1e264f1d487c8b398f5c4fafad4edfcdb67352d49bad8872f341c2f976a37dec6fa5feb9b6ffbd7550657366a134d1a6237e75a2489441e2ff65c3e2fe128f5485ca2d509034caf2f73a20dfd5049cf663c3a708acbe83aed7f07fb4e70c506daa2f9868706b0699ccaa7c0c2cd6eb408b7af663404a80a3c1222f243fd904e18f42cfd0e4737a9ff84f76d4d871533cc58eaa8bf2f5d34379ad603186ddef56a51d4a3ef5a7c5c99df91ad157ef7f5899b4cac6ef6ae11e7dfa51f6c891b7acfbc48a1dcbb691ced7f2ffe35505aa9f9139818c317f9680e436015f09daf68bf9d991483ea28783457befda438971ddce9077d0eebc007ee2f90298d561d98cbdf5986679240778ebc2350c539b2639f1e3b352d083e97129a7d14d96da97ba3381408702489c888e64e8a9426dedacc75b5c0ce365840d1a4732d4120449be007869079c6324cf284ecc87d3ee143251e8d8bf50375dc559018a9e0c68cccab754286d84318b0f38f21ac05cf80b59c5f90a0fa057b80c5579c1bef67f6e512f6895d193a166f57cff8ecfc6e39d1be755364485ebb87d24f1ed36eb03640dfd096ef8e7bd10a3d676d69cd051877d3efcf58b0e30bd1269797fe272c1df1bfac949706fcb4a16e5cd7356e2cd9ffe0a282c3f4b9689081d00d1d2332b40bc6025ee793f48ff1c324e64d89364654d11dacca17e0ff89aeb730508e3d38290dcfe4bf4f5cc931bd8584100c39fe4c6d3c11244485711a0a1e5189b723cf62c47dee52e023c48b20ee07c82e50a311f65eaebedbfd6171ae84456b177fd210c34d17475050209ff33c2cee76cad9ed28788e0ed4001f9a91089bc72b1fee937bd079d103a633def76c43e0538279946dc6408466a75dd6257a014d4d090537db68487e694c9fd36f1b0c93ea4895818beb7c697d043e93067bf2a3378bed929720daa9ccc4362befa7817a07d16352f651b2e806dc01567772e4abde54413eb613a339a634f601f117305ad6164592e35524076e8a1fe4fe262bb4d88ba8e3fe2ad19f7275d37114a27d66e472623b915bc17ea9b9149595547b65b132c5ce3d6357d2d7e554b73c0e11e8b1506ddafd4007b5e056623c93a100d8269b615f91e0c049c54b2fdd8c981e2ebffd0f483f262b3a29865b6d53ba6d23bd502cd51d813e10cfbe03c95cfe9d23d4e7c55e83ec960fee3091b5a8b59b37050b80820534ea55b3a99fbcc7546674571f98a6e3ce4c5a578788246eef462fd14c8baf24bf82d894ccce3b0f23ae5d084d6cebe11d0727252bf9ac24495122e01c6e6b6fe4a5eee4176b91c9f54641a0bc911aef1b2b330c944bdc4e0deb440dc041dfdf089ca7222c92d82928b8c223189530d232e89d2f23f3e0a4a4f41588d5fc3ff1128b3f298ff1b3ed9b935b2c089982f0ac210def0f2d2c51b3c6333b163c0f63e2ab52414f0d7c6209e5e81f58a98f8281a50ade8c9646f28db8994156a0a077d6e3030f923707c50308851eec42cffd8311c46860817d97402541ef1d71ccd9f7aa481d7b2e01ec1fb35197bb47a5dc5c8dd04ef38a764ad70fc19e2876020be63c1a6270e101aabe89821766fc3c05c0ed4a1782b625eb9fbae0dec28657e6dcfa49af44801d500493cd1a1ce9f05486d64f1cd02526185345b838bda9af827cd875c63b063461827664a6171b515654171a9c0dbc2576c23159c3db8f165251f344184ecd65f84044bc84f4e041dfe15c8842f83ca5429ecb2d43726d6509c45cdf91271f4d1018d0db96f78cd5332b31d15daec1d4f52ed47b0fb8f709cebeedabb74d684d694153b215e1b63f407f734d550ef93461e289fd6549a698bc74857ae6c43ebba0cf4ed08856568beff39a84b8a5a39e3703e3f252f48d321594c00b2ae1bea358faa6f40b8f4f620bbc756ed6e850ff8f967f4b4a924adf9be06a0c5831c6b1774a2c76f9e18f3e3304cb7fd3fe54baa4db767451e5b1b375b3936a28d2ba086ab89264354d1d34f3e13d1b7e7a4d75eb7db0e2e4750e502fe3250baa043758a112fa243d73888e22a07758a70acb9bba2bf8f7de41f6c58f09e13ff25bbeba0d532d5ffcdabd609b8bbd8d1cf6baed566aef4c83eac077b937e3f3bd0420ed3c03de2749d4f7e4ce50e51977ddc2ef340a88d412dcd6425793d35edaad95ad567b340988457cda49a69621f69ea0fe55e72cd54e0268ce58f916832531deebcea22ae270aa81cd11c554827679934ba0d779ecf2d8ada348a59d3ce2275ba3ec68a6c519d8f45934f1220c36a10186a4cdc0919d09cc29c29aac155100fee53e9f9b6baa1da58c0960b2d305a8f70df9c61694cc3bf9fd34e94b286e4c8313372cfe76f7a5aa8c2bd358275a244dc9694a547fa3a25f09bc2ab244ce910e91446ae6c221a5873cca52a635a8070d0e77197d1d6af71d38c58795f9b41f6857bc376abdf0c302d5e44cb5a5466533d020529851ea79b35915d4bcac0e5e091fc4a437c536d12f1783d6576b7b232a03949b5307e85889a92daad94f07ab238c061f44cc3bd440305ea9b037e63621eef77062dffa057a76dac8dfb7b3284f98a4c2f0ab96c0b2bdac082247a56bb3be1fe4843b0593d7e43a31092b14f2a95843f5ae8ce4f0677a69f8a42e8de926b2ee156461285dd89a559f9a2e53c718bde4fc0390791f1246da15adf1103d05b02bf8b0f65f4c3d2d50b9cbea8cf319028fa87cfa22beec0791f1a84971317a556909026a3bed7cb0e135523267c7d431739f0e8935341ac340a47009704d5112b847bd56cb0b2ea51169f837e4a5062a62624b5e2020e1bed151d2c7cad9e3e4b1eebc8aacf57a76b332ed0ab2e393f03bd32d8ff4b643523e258f4c75aa0eec2fbf2f7b92e7c1f5e303be547bc2ec9789277199c4e33974fa9f5b5594f1985acaab94e5c4cb5abf4f342deae3faf0c65f9aeb311393eb1f3e13c99e389651b2660932c385313fb14a4ca1432d11daeaaf6d7f3a40fe2b934a97461c7bcbe162f97708fb2125a6baa7ad611a4dccf4c253858b9aa47a05b911589dabdf509a115d9454d73028cba147266a79128e13626bf3e934503c13b67bf432c9cace2405fc30be26dc24015c6b7ede72304c73ff80dd6e1dfcbdac990c32a13cbed5fa85794e81e588edb42fd517df926ed70f30d017cb6f1d12ecf95e6dd594abb2fe86987b792368ac9dcaea15f6cdeb9dd84669dac48a7197991499adb87b72789759dd800e7a3de1308ed50fa40d43a5c82329e33f699c0747f874cf704947f3c1069b79b0262a7755c6f59215602ed7f16247f0e30de856f7a7402dcad8ad9f4a319dc8208e04019e236fb4d4ebe341a598f3ebef8aee0c3571a2fd529dd09f9601761f5b9f47b5b27e8c6b77ccf092d8b489de9260442d59b01c9e0d4735983f03aab3df8bc71bac12c759cd3841d395665784a7e92a085f881230fcb63571559d791475707474e8f4464605a99124865ff0e1c047480470f1a7c4b1729b07fde8538e32ae963cec682c0b8205cecf2cda32137ac6136c43665965b4dd0a4c7d02e736211df991503a6f83a2c0599db5f7d8b3a1635992f90ea2e2fba0f62a3cddba9ddad152e3618bfe83524315cd731197e5c55a92235bfaeae0a5740fee30679cc8b182dfb8490586ce2175209250e970e08c7ea2caa839a022e72c86d59377a9ce99e4d7c90477ddb0f2ca2bc4c905def1b9335fe9f55f9fe8175e27394a36167c5eca33a9f08f9bc4ae1a8da7459ed542bc87697518543e95922a064863aa607733e50154e6f9eef17ed2e8c1c4fd7b3f81f7ad4e9dfa652a8d01e0630b70fc1e34dc2fffeddec4547a66f2bbce494244df269e61247624e7a0bc6cef0ecac0f58fbc0f165843c450bad0e4fc4ec5b2ff9c77a402b450cf8207d6b8a9b4704016dfd4e79e558bb2c2c32350551504a6fa0336c1565b6545cf7f73a559992c3b4471af8137281b88a93ea17afc5ece1ee84def3994d40d48ad4a99f56db322192ea2efe3adea6d10942530ea35e8b7836cb6af4ffb2844af29931f6b56d6dbde109c0b86ad0cb3fc59016d0087152c5c23ab44c58bf202a4a21000252ff09f2fd7e32224561d2bf5f9d380cbf3e40c2d84bfe50cd444ac71b209bdf69babe4c7e0bc3c399b3504c7e0cbd906a5af97b1ba8ab341950912bcb89b62c1002349aa7ce82df7e9e9096ff16105498de39eada6e6d535a75ed90c997d4dd22279fe5fbae27ffafc2b703833a9cfc7d1255f4f914bdd6b5f9d470d9c9881a080136cb3f671a291cd81851a81780412aa96adfeabb0075c0772bfa580cf9b733fc7613a74885b843ccec52b478723885ffebfcb87c70afb174c397ce1566c86ae5e1ff0877925270c55528518b2df0d2ade2f8ebc23bf8cc26935907b5e2fc6b0786cdb25f9aeb5c8fa2f634f655660ab499918862ccbd9a364e6e8ac04c10a5ea6583170187c5571a0d4841f2cc3786d882deefc396d22ccbc605b0660f03ac720b9881bde6027e4fa26d851982cfc0ff2a898877734216fabe60990fed3a7d1b654df292e83d01b602798b9599b476bf5b527d0a61eb1d1720539fad5a707748ef1c37bbd130bacbd1f1e8748871d081c0a3fd3b6ec71b34d0e8a86ff9e8c25eb3ff8ac866fde8d6196f1f99876f67e1ea9a30d318a48ab4dcdfd5ff08cc3f841dd211dc30fd5d596717bdf9f2d8976be40236c9bf2cc2692ac96e7200533ef284bc592dba3f74f954d5690a84e4ee6ee632691c088702e3d2bd4790d62cd5814bbd556b5ae250079a1efe12d354736a89bf459aa7471652b397f29159d2a532bfccc7b8ac1805da3a96a04351d178484103ddca01d4b636e821fee23b47ac572ac13b854ec5c9433c8a23a138f8e8a169c268dcfe5052f6d25ddd49e1bb1b86c2b30294576deacc227a2caf0a45a482781f007c1ee5fd31bed7ec19707711757289e3c0d69c3cf1e437f14e0da4e8d6f1538f05f5ad80bb6d375ae67306153aa97b9e543fbeed6c5f1e7229bf29b90757446d115bffee61148e0842f11a1e4f0c67692a54ea11482fed93e2f908df44bdced216c52518a86dbb7c4487cbcfcc4f13aebbfd20d77c2c37c6b559005358ba5856ba2457a0f689c731b9d74c9f1cac3912976029f1d20b29c7d88e466c1fcf8500d517ebd4ef6712886f5f4cb858a53cad9b76ebdbc63aa5d737515561a0e54607da72bee38216348ae7c3c193aa4528127d04ac10e8d2a18c52461c83bc355ca676636d64c5778d234e4c9bc19fcf8b8ff618f910a2822f8abdf8c0ef3465b05e27c4110f70756425a156fe455f3b2d5cdd0ebc0e12c83e243cfeb0a2f4df8afad4a9816e855a32adc1eb43623f5d9738d2db989c4072a1ad6ca849b09d3f78a721d6568a93a393b8559cf7dcb56d9aa662c5abc1bf76f9ac137120acf0acc5f0990ef7661101a2af4339100e7d35e5779342ec72f62d73c4e5edf5c0ac5e531a70e36617321a39197b2ef69684e0c050b74815569eba558a4786413747291c7fe591d826bf679a04c597a8e6486899104c8322e543fcb5121736b536d19ddd6d2d278a5b4328fe05b9fa6c514a4c558c6c1d508007881aa2c1cad143668","link":"/2020/08/09/Ubuntu%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"Command","text":"嗨，请准确无误地输入密码查看哟！ 77edc8211bba2098425d90011f4162589483f10b14f19c4b6c27ab36252aed8909d70133097d08b219f402aca8cd9a01f56f800fede6766796d60f6a49abd322b3fbcb61dc0d85a0119589aae081fc4f99c15c24698efd4ab9643b7b892172c6a0946889cc32a4b00031722fc676cdd8e4b4a1689ff3ecfbe72508922e7b1a0d34384ec187d06cefeaebc53ea90d420ad8aeae13d7a20a247ff8d031c5008144db9c154647393d08b922348722677a0936d0d9c936d9acc6fde87ed285065949e93d588eb7ef1ab3b279d0a34cadc6459ab24fdd0f9547cfa3558912b989995b56755e71e9dd211752f5d4fa00d035a6e40698d1fd6a0c8f7fecf1faf0cadcc05c015d58cd33487266dcfad1dc0db9bef7a356b58287a753c11938a0b393d47601d04fd4b8c3f85b4c09a6612fdd319f5cc5221668d6d8a3ce155210320c2e5888d2634ec8d378e0469fc1895f9fd0e1f483caaa1b9f9b95e235f5b12010117a028eff497090c19a1ba5e983a67a9d9162a43138d44b3c33cfc4eb2b8edf7ba2f784f882b827653cdb6f4c8d666912f70298469b97d83b03c8735c4b0795b9c69811176087daa64070a4b9a0e34d45ddc61e609e98882b793eaa3605e4ea6b0ddc3ef8bd88a54bd93608dea49a60caf1ac3b203e845e9f2c5bc7cb5044e59d67e01fae79ec9f1119c9cf37895620705b272ac7534a2ad06b47d096bf1a21b797ced21fbc1cdf80ba1f4464c1df64d7d7370ee1b212da9801e043edc8c8953f6cb471c698d719bf68511a49b9764db679378eddec12ad899b96d21561a40d40bd7110e51c4fca5e0e7fae634fd3b45dcb6c218be3fa1529d122bd5835b4f656c51d20a60f1699994ca173f11d27aba5defd746a3a8f305f4f328f14893d63efe9cb6d605ad83864e0dbd2d5bb6fe0efc0e0a30aa0222dac2dfcffa8c9a81917519afd9dfb2414cb2c6640da0dd01af7f279987856b004fe8d50a678b3f9c0947525c43587ec67ada555eba09fa6a4ea471e56975b103e66beffcf379f58abb5a6d1cd72f6bf08b53db8ee9ec8654bed6e1140b9e1168ccdcc59dd74a922524c7619cc069a9ea0175f968f9b8f87f22a5300b3e2215fdb5973f21350a3cbff3faf5c484c48a0dbb3102321e5a401bc78e730fbc1ada625d9593b02c82f2c1b9bfd874735598ed2b0a44ba3f117d7b0355cabfe03197e8ff48df3995de77c2f108b7e83c5cab4e9e53561eae313ffc2a896dfe1fc8ec9c0bd91387c2ceff2ba29ed2e09a86aeca7b5861ee47bd093edd61585438eccf83d531c4ba8b36a0234550650c19bf3da4a10c540b694f831581b93601c38cf5e6f1ccd1d5995cc683d6a9b0d2e445029f2ec611212c32e4caf1fb8d07393f1f3c463a07b0ac008e3f1985d464ea4ae7f221c26b8622aaf536124d0baf3bd300ec91dfb9502d540f516d95189d8503c97eca765cfe94d8bad908d6230b6b87cfc70b3ffaf2ecdd6762f595608917bb717cb080d468bea7d1e106bd47a0538641fe1e04d2b6c216bc8be422b8530b01f0e8e768d0b774add02bcb3312d6c1433926846523d896fa099dc88df2b80b6d625902b6cb2adea41bcf3c25d7b5b9d9348c020449181ca3cc74bd8f4d0cd066e03087b116d44c5b95f10bd8ec054c13eb8b86da938cdb7b07b34d109d141dfecce512cc4ee3abd43cf5b6164647fbc32b7ab6e4cf1b953818d0c4e26cef73797feff35e24d532efe4372e69e1390dfb3484760199a50abe82b11045f4eb2f2c746fe64ba5930fe39277a0bb9b76d3614cf56de59528b9fcc2134d98983759a56dacec133e8c41627e612821fdd069c114794cbb85c2019367dda922d09734b3f4425182d924b8f66a4f2b8881abbdeee313737feed48f6760fad3629c93f3d676b5b2b52277a6b47d49c4a9764eb99eaa7ba00b2307ade2f0b41077e672de2899e7b1f334bcb9ff31a85ab9c56d9565831f14a6d474b1ec39b7e3a7aafe91529f817087f708bf49f0a310abbb66917dc77f194d0e782a0c902ec6b76a40e21e476818949db75c0cf245a82072834905295bcf5ee5d1dc2b57e83a31c1c22ceae233ab22dd85615c8f5c73ebab5c6580b7cb06ef12151b643ed6c526c937075a268a560559b66c698223863e09fd93a869f06209757eee90f2a56a50342dbfa69e45cbb5eba6b5e3d494288796da253c187a921c048238f890d3642800437dd1e63acbfa266f9b9fb55af3a3c4c9d872882d4128a9e3eb9b0c55645d0353ce576adfc35b291aa6d22bdf59860aa93c1b74aa675280ec9a82d03c756c77696fca4f05e7dc1bd4da3249fc8d30e127e0cc433311edfa12b0701be37fc7b55aef6e8404b90ac90b243fcc8e13562e176c9b36625a7cdbecf89d355811d51ea25e4354561dc2afd96e68b42012ec2770bfd3f1d79954fc6019db5e4c32e13f680bd0442717fdab04aca9c5a1d537b1ea020bc1534a266ba39b10b87ad1211db13dcd00149314d7ba591627533241971e985f1dbb696265877c00901f3d44193ed3c7d632b711f22bce6508c444074a1e379dbb9fc3edc7941cf7ff15ec5737f31f9876cbede954f63da40cd3b724c565beb70644445e63e42a795f8a0717f0a3d7cf2ee9a2d51fc6b0753413a688ceb627c52f1d04bf7cd2116307a30521359e1bbaada8974bc0efea660187e4905521378a1561911b5c6fd1b48a8f6c93f7e85b4845f8a95f5037952d1ffff8cd88bc6c805033e46f56866eaa693a8e49222313588e373677970210d1a4679ce66e36f5a9df25679f03d3ebdb09966ca6d7b4c76a7b0c2ffe4f5ac338616b1c48aac60be6e6ba45db9826d619df4c9583283e1f4b64eb96f774d07c6d88d249c071214a5f4c2f2c471a6970474653fbc344369e0d2e0bc6000da4907263de02ef135618a536efea5102e10b3a2bec4be2d3c62f794285fb98a10f1d8c7df3e753a98e302ef89567e9169e12b95a6418cfafc01221d8d01a10cbd457a2f0842a9b0c652c01b53fece6490c407f6a9f7df73cd8dfce85b2cc5c2aea57c9f75f8f7569425e761eef5b1923c329e27f6be902bbcbb32c60aa96c80958d9fc23e1aeb0d4f4ad338d8797f8659f18472675d75a2c96ddce594c3e1d87149cbfd3cb9d70ce97d283daad979962285c120a90c99b95701da6a052e4059899948c325d995b8cce6b77b382d5fe85829c8a291f0adee0c0e50a45b3baa20811a881a1e3ed315d972322dc32ea6b189dff419c4a7d231e2c9e751bb59b52b848f3a70121f637e5d6ce19b772a51306cfaf7b596ec8ab3315aeea994653095de4e57a78581045c6b1bab2bfba542a8909c137036bbbc90eff04f3b364e8361255126802f6c5db0c33bf69ed61b8dff56408b668fdcab425d4e929b4bcacb8517d562bb06e273c7b87502ae95454a7646bf52938b9c4809cd5ef83df7f62f28253dc5a6cd2b90e8b7b82d6c914252ca5b645bfe3e87935c92b3957eda45ce05ff8f31c17ca5b0ba2ac6dad1a711b8cc8a308b2b28315cf8677ad01efcae13c6e1ddb2c19c27e3cf57e5586d1814d10c13810ad0918a530f738d99108f303c8bdbfb39fa079501b854fd29ec70085c7d6238f8738e467702de20cb167111f7e1e6c267ecdb4c16f1161f7c96cb7eec9d9f0f1ae44f530e63fd407d620a79c064e7c3a3301f5c8ae4f21b8fb6bb34ba3292617feda5609b1a0d0029b3bd7e5ebd9d394b3032abd5e47a7a33f03c2f0091a9ac4d43dc2f477d0e300aff9f1463fde5020c1b4456dcbabf8fa66e7e403c58f764ec3b74984a9293334c75ded5ee61b5f41d777927973dced9c23d3bbe23acdd81b15a23bc834b9db7a9ab67f3029d1d133ff9fc6464843aa92531e5091e36e0418e9488a297330a7f4625982911bb335ba4893649b896344138d3ff003727de93eee592402d1fc00e7debc5d577bcb929f76e3597a8cc42fe4325e01d7fd7f6cb6e631a80c2a0286052c5986d1ac37ee8594cfa0dc2a0438abc2cbf76dcd74710fbd1494cdaca58f2d0269788ae6069568af81cf618fd","link":"/2020/08/09/%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3/Command/"},{"title":"setjump_and_longjump","text":"setjump_and_longjump setjump和longjump函数及使用注意事项，C语言setjump和longjump函数详解#前面已经阐述过，对错误处理而言，goto 语句只能是在函数的局部作用域内跳转，而不能实现跨函数跳转。但在实际错误处理中，经常会遇到这样的场景：在一个深度嵌套的函数调用中发生了错误，需要放弃当前任务，从多层函数调用中返回，并且在较高层级的函数中继续执行（或许是在 main() 函数中）。要做到这一点，可以让每个函数都返回一个状态值，由函数的调用者检查并做相应处理。 很显然，遇到这种场景，goto 语句就显得无能为力了，而 setjmp 宏和 longjmp 函数组合就提供了这一功能，它们能够提供一种在程序中实现“非本地局部跳转”（non-local goto）的机制。其原型定义如下： 12int setjmp(jmp_buf env);void longjmp(jmp_buf env, int value); 从上面的原型定义中可以看出，setjmp 宏与 longjmp 函数都使用 jmp_buf 结构作为形参以保存程序当前的堆栈环境，它们的调用关系是这样的： 程序首先需要调用 setjmp 宏函数来初始化 jmp_buf 结构体变量 env，并将当前的堆栈环境信息存入 env 中，为以后调用 longjmp 函数恢复原来环境信息时使用。如果是直接调用 setjmp，那么它的返回值为 0；如果由于调用 longjmp 函数而调用 setjmp，那么它的返回值为非 0。由此可见，setjmp 宏函数能返回两次： 第一次是初始化时，返回值为 0。 第二次则是在遇到 longjmp 函数调用后，longjmp 函数将使 setjmp 发生第二次返回，返回值由 longjmp 函数的第二个参数给出，返回值为非 0。 相对于 setjmp 函数用于保存程序的运行时的当前堆栈环境，longjmp 函数则用于恢复在先前程序中调用 setjmp 函数时所保存的堆栈环境。当调用 longjmp 函数时，它会根据变量 env 所保存的堆栈环境来恢复先前的环境。与此同时，longjmp 函数的 value 参数值会被 setjmp 函数返回，程序继续得以执行。如下面的示例代码所示： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;setjmp.h&gt;jmp_buf buf;void F2(void){ printf(\"F2()\\n\"); longjmp(buf,1);}void F1(void){ F2(); printf(\"F1()\\n\");}int main(void){ int jmpret = setjmp(buf); if(!jmpret) { F1(); } else { printf(\"继续执行main\\n\"); } return 0;} 运行结果为： F2() 继续执行main 从上面的代码中可以看出，对 goto 语句而言，setjmp 宏与 longjmp 函数不仅能够实现跨函数的全局跳转，而且其错误处理方式也比 goto 语句优雅得多。但是，在使用 setjmp 宏与 longjmp 函数进行错误处理时，必须注意如下两点。 1 setjmp 宏与 longjmp 函数组合使用时，它们必须有严格的先后执行顺序。也就是说，必须先调用 setjmp 来初始化 jmp_buf 结构体变量 env 之后，才能够调用 longjmp 函数来恢复到先前被保存的堆栈环境（即程序执行点）。如果在 setjmp 调用之前执行 longjmp 函数，那么将导致程序的执行流变得不可预测，很容易导致程序崩溃而退出。 2 longjmp函数必须在setjmp的作用域之内。在一个函数中使用 setjmp 来初始化一个全局变量（jmp_buf buf）buf 之后，只要这个函数没有被返回，那么在其他任何地方都可以通过 longjmp 调用来跳转到 setjmp 的下一条语句执行。也就是说，setjmp 将发生调用处的局部堆栈环境保存在一个 jmp_buf 结构体变量 env 中，只要主调函数中对应的内存未曾释放，在调用 longjmp 的时候就可以根据已保存的 jmp_buf 参数恢复到 setjmp 的地方执行。 其实，从上面的程序示例代码中不难看出，如果说 goto 语句使程序变得难以阅读，那么 setjmp 宏与 longjmp 函数组合这种非局部跳转会让整个代码的糟糕程度增加一个数量级，因为它能在程序中的任意多个函数间传递控制。因此，应当谨慎使用它们，尽可能避免在实际编码中使用 setjmp 宏与 longjmp 函数组合。尽管如此，在编写信号处理器时，它们偶尔还是会派上用场的。 最后，需要注意的是，无论使用什么样的错误处理方式，都不要忘记发现程序中错误的最好方法其实是执行程序，对代码进行逐条跟踪，这样可以观察数据在函数中的流动，同时检查出类似于上溢和下溢错误、数据转换错误、NULL 指针错误、错误的内存单元、用 = 代替 ==、运算优先级错误、逻辑运算等错误。","link":"/2020/08/09/%E7%BC%96%E7%A8%8B/setjump_and_longjump%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"ESP8266开发学习笔记_BH1750光强传感器","text":"ESP8266 开发学习笔记_By_GYC 【BH1750光强传感器】 BH1750是一个光强传感器，能够对环境光强度进行量化，转化为环境中的光强度lux。它是使用IIC总线进行通信，通过读取寄存器来获得传感器的真实数据。我们常说的智能调光，就要用到此类传感器，因为这个传感器的精度还是很不错的，可以使用这个传感器作为反馈，将环境光照度稳定在一个期望的数值。本章主要介绍在 ESP8266 上使用 IIC 总线驱动 BH1750 光强传感器的方法。通过PID稳定环境光强度的内容将在后面介绍。 一、BH1750是什么 二、驱动原理&amp;代码 三、结语 一、BH1750是什么#BH1750是一个光强传感器，能够对环境光强度进行量化，转化为环境中的光强度lux。它是使用IIC总线进行通信，通过读取寄存器来获得传感器的真实数据。我们常说的智能调光，就要用到此类传感器，因为这个传感器的精度还是很不错的，可以使用这个传感器作为反馈，将环境光照度稳定在一个期望的数值。本章只介绍环境光传感器的驱动，通过PID稳定环境光强度的内容将在后面介绍。 二、驱动原理&amp;代码#BH1750是使用IIC总线进行驱动的，IIC协议仅用4根线 VCC、GND、SCL 、SDA 就可以实现数据的交互，在BH1750传感器中还有一个位（AD0）是来控制不同地址的，置不同的电平可以改变传感器内部的地址，方便用来在IIC总线上做设备扩展。 关于IICIIC驱动我己经介绍过多次了，很多设备都使用IIC协议进行通信，但是他们实现的代码略有差异，有些只用到了部分功能，有些则是用到了全部的功能，有些通信速率高，有些通信速率低，但他们都是IIC协议，基本原理不变，规则不变。接下来我就针对这个传感器编写了适应的IIC驱动（C++语言版本）。（PS：获取以后有机会写一个完整的软件IIC驱动可以应对所有传感器而不需要特别写一个） IIC类文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 class IIC_Device{ private: gpio_num_t sda_io_num; //I2C_MASTER_SDA_GPIO gpio_num_t scl_io_num; //I2C_MASTER_SCL_GPIO public: IIC_Device(gpio_num_t sda_io, gpio_num_t scl_io) :sda_io_num(sda_io),scl_io_num(scl_io) { gpio_init(sda_io_num,scl_io_num); } /* * IIC GPIO初始化函数 * 参数：sda_io_num SDA引脚，scl_io_num SCL引脚 * 返回结果 ：成功 */ esp_err_t gpio_init(gpio_num_t sda_io, gpio_num_t scl_io); protected: void IIC_Start(void); //IIC 开始信号 void IIC_Stop(void); //IIC 结束信号 /* * IIC等待应答函数 * 返回1--应答出错 * 返回0--应答正确 */ uint8_t IIC_Wait_Ask(void); /* * 写一个字节 * 参数：要写入的数据 */ void IIC_WriteByte(uint8_t data); /* * 读一个字节 * 返回值：读出的字节 */ uint8_t IIC_ReadByte(void); /* * 发送Ack 应答信号 * 参数：是否应答 1-&gt;NOACK 0-&gt;Ack */ void SendACK(uint8_t ack); }; IIC实现函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/* * IIC GPIO初始化函数 * 参数：sda_io_num SDA引脚，scl_io_num SCL引脚 * 返回结果 ：成功 */esp_err_t IIC_Device::gpio_init(gpio_num_t sda_io_num, gpio_num_t scl_io_num){ gpio_config_t io_conf; printf(\"init BH1750 i2c\\n\"); // disable interrupt io_conf.intr_type = GPIO_INTR_DISABLE; // set as output mode io_conf.mode = GPIO_MODE_OUTPUT_OD; // bit mask of the pins that you want to set io_conf.pin_bit_mask = (1ULL &lt;&lt; sda_io_num) | (1ULL &lt;&lt; scl_io_num); // disable pull-down mode io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE; // disable pull-up mode io_conf.pull_up_en = GPIO_PULLUP_ENABLE; // configure GPIO with the given settings ESP_ERROR_CHECK(gpio_config(&amp;io_conf)); ESP_ERROR_CHECK(gpio_set_level(sda_io_num, 1)); ESP_ERROR_CHECK(gpio_set_level(scl_io_num, 1)); printf(\"\\nBH1750_SDA_GPIO:%d BH1750_SCL_GPIO:%d\", sda_io_num, scl_io_num); return ESP_OK;} /* * IIC 开始信号 */void IIC_Device::IIC_Start(void){ gpio_set_direction(sda_io_num, GPIO_MODE_OUTPUT); //SDA_OUT(); I2C_MASTER_GPIO_OUT(sda_io_num, 1); //IIC_SDA=1; I2C_MASTER_GPIO_OUT(scl_io_num, 1); //IIC_SCL=1; delay_us(2); I2C_MASTER_GPIO_OUT(sda_io_num, 0); //IIC_SDA=0; delay_us(2); I2C_MASTER_GPIO_OUT(scl_io_num, 0); //IIC_SCL=0; delay_us(2);} /* * IIC 结束信号 */void IIC_Device::IIC_Stop(void){ I2C_MASTER_GPIO_OUT(scl_io_num, 1); //IIC_SCL=1; I2C_MASTER_GPIO_OUT(sda_io_num, 0); //IIC_SDA=0; delay_us(2); I2C_MASTER_GPIO_OUT(sda_io_num, 1); //IIC_SDA=1; delay_us(2);} /* * IIC等待应答函数 * 返回1--应答出错 * 返回0--应答正确 */uint8_t IIC_Device::IIC_Wait_Ask(void){ int count = 0; gpio_set_direction(sda_io_num, GPIO_MODE_INPUT); //SDA_IN(); I2C_MASTER_GPIO_OUT(scl_io_num, 1); //IIC_SCL=1; delay_us(2); while (gpio_get_level(sda_io_num)) // { count++; if (count &gt; 250) { IIC_Stop(); return 1; } } I2C_MASTER_GPIO_OUT(scl_io_num, 0); //IIC_SCL=0; delay_us(2); return 0;} /* * 写一个字节 * 参数：要写入的数据 */void IIC_Device::IIC_WriteByte(uint8_t data){ uint8_t i; gpio_set_direction(sda_io_num, GPIO_MODE_OUTPUT); //SDA_OUT(); for (i = 0; i &lt; 8; i++) { I2C_MASTER_GPIO_OUT(scl_io_num, 0); //IIC_SCL=0; delay_us(2); if (data &amp; 0x80) //MSB,从高位开始一位一位传输 I2C_MASTER_GPIO_OUT(sda_io_num, 1); //IIC_SDA=1; else I2C_MASTER_GPIO_OUT(sda_io_num, 0); //IIC_SDA=0; I2C_MASTER_GPIO_OUT(scl_io_num, 1); //IIC_SCL=1; delay_us(2); I2C_MASTER_GPIO_OUT(scl_io_num, 0); //IIC_SCL=0; data &lt;&lt;= 1; }} /* * 读一个字节 * 返回值：读出的字节 */uint8_t IIC_Device::IIC_ReadByte(void){ uint8_t data = 0, i = 0; I2C_MASTER_GPIO_OUT(sda_io_num, 1); //IIC_SDA=1; delay_us(2); gpio_set_direction(sda_io_num, GPIO_MODE_INPUT); //SDA_OUT(); for (i = 0; i &lt; 8; i++) { data &lt;&lt;= 1; I2C_MASTER_GPIO_OUT(scl_io_num, 0); //IIC_SCL=0; delay_us(2); I2C_MASTER_GPIO_OUT(scl_io_num, 1); //IIC_SCL=1; delay_us(2); if (gpio_get_level(sda_io_num)) // data = data | 0x01; else data = data &amp; 0xFE; } I2C_MASTER_GPIO_OUT(scl_io_num, 0); //IIC_SCL=0; delay_us(2); return data;} /* * 发送Ack 应答信号 * 参数：是否应答 1-&gt;NOACK 0-&gt;Ack */void IIC_Device::SendACK(uint8_t ack){ gpio_set_direction(sda_io_num, GPIO_MODE_OUTPUT); //MPU_SDA_OUT(); gpio_set_level(scl_io_num, 0); //MPU_IIC_SCL=0; I2C_MASTER_GPIO_OUT(sda_io_num, ack); //SDA = ack; //写应答信号 I2C_MASTER_GPIO_OUT(scl_io_num, 1); //SCL = 1; //拉高时钟线 delay_us(2); //延时 I2C_MASTER_GPIO_OUT(scl_io_num, 0); //SCL = 0; //拉低时钟线 delay_us(2); //延时} BH1750驱动本次所写的BH1750是 通过使用IIC类作为父类进行实现的。BH1750继承了IIC的特性，所以可以复用所有IIC中定义的功能。 本次编写的驱动库中，支持对传感器测量精度的控制和传感器值得读取。 光强传感器类定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class BH1750_Device : public IIC_Device{ private: uint8_t SlaveAddress = 0x46; //定义器件在IIC总线中的从地址,根据ALT ADDRESS地址引脚不同修改 //ALT ADDRESS引脚接地时地址为0xA6，接电源时地址为0x3A uint8_t BUF[8] = {0, 0, 0, 0, 0, 0, 0, 0}; //接收数据缓存区 /** * 通过IIC向BH1750发送数据 */ void BH1750_SendByte(uint8_t data); /** * 通过IIC读取BH1750数据 */ uint8_t BH1750_RecvByte(); /** * 向BH1750目标地址写数据 * 参数：目标地址 */ void Single_Write_BH1750(uint8_t REG_Address); /** * 连续读出BH1750内部数据 */ void Multiple_Read_BH1750(void); public: float data = 0; /** * BH1750运行的精度模式 */ BH1750_MODE currect_mode = BH1750_FAST_MODE; BH1750_Device(gpio_num_t sda_io_num, gpio_num_t scl_io_num) : IIC_Device(sda_io_num, scl_io_num) { init(); } /** * 初始化BH1750，根据需要请参考pdf进行修改**** */ void init(); /** * 读取BH1750传感器数据 */ float read_data(); /** * 设置BH1750 的精度模式 */ void set_mode(BH1750_MODE mode); esp_err_t delay_ms(uint32_t time);}; 光强传感器函数实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 通过IIC向BH1750发送数据 */void BH1750_Device::BH1750_SendByte(uint8_t data){ IIC_WriteByte(data); IIC_Wait_Ask();} /** * 通过IIC读取BH1750数据 */uint8_t BH1750_Device::BH1750_RecvByte(){ return IIC_ReadByte();} /** * 向BH1750目标地址写数据 * 参数：目标地址 */void BH1750_Device::Single_Write_BH1750(uint8_t REG_Address){ IIC_Start(); //起始信号 BH1750_SendByte(SlaveAddress); //发送设备地址+写信号 BH1750_SendByte(REG_Address); //内部寄存器地址，请参考中文pdf22页 //BH1750_SendByte(REG_data); //内部寄存器数据，请参考中文pdf22页 IIC_Stop(); //发送停止信号} /** * 连续读出BH1750内部数据 */void BH1750_Device::Multiple_Read_BH1750(void){ uint8_t i; IIC_Start(); //起始信号 BH1750_SendByte(SlaveAddress | 0x01); //发送设备地址+读信号 for (i = 0; i &lt; 3; i++) //连续读取6个地址数据，存储中BUF { BUF[i] = BH1750_RecvByte(); //BUF[0]存储0x32地址中的数据 if (i == 3) { SendACK(1); //最后一个数据需要回NOACK } else { SendACK(0); //回应ACK } } IIC_Stop(); //停止信号 delay_ms(5);} /** * 初始化BH1750，根据需要请参考pdf进行修改**** */void BH1750_Device::init(){ delay_ms(10); Single_Write_BH1750(0x01); } /** * 设置BH1750 的精度模式 */void BH1750_Device::set_mode(BH1750_MODE mode){ currect_mode = mode;} /** * 读取BH1750传感器数据 */float BH1750_Device::read_data(){ float temp = 0; int dis_data = 0; //变量 if (currect_mode == BH1750_FAST_MODE) { Single_Write_BH1750(0x01); // power on Single_Write_BH1750(0x13); // L- resolution mode delay_ms(18); } else if (currect_mode == BH1750_ACCURATE_MODE) { Single_Write_BH1750(0x01); // power on Single_Write_BH1750(0x10); // H- resolution mode delay_ms(180); //延时180ms } Multiple_Read_BH1750(); //连续读出数据，存储在BUF中 //printf(\"BUF = %d,%d,%d,%d,%d,%d,%d,%d\",BUF[0],BUF[1],BUF[2],BUF[3],BUF[4],BUF[5],BUF[6],BUF[7]); dis_data = BUF[0]; dis_data = (dis_data &lt;&lt; 8) + BUF[1]; //合成数据 temp = (float)dis_data / 1.2; data = temp; return temp;} 需要注意的是，BH1750光强传感器有三种精度，一种精度较低（4lx），但是可以转换速度快，每18ms就能够完成一次光强转换；另两种种转换精度高（0.5lx 1lx），但是转换速度低180ms（手册上写120ms~180ms）才能完成一次光强转换。 此外该传感器还有两种读取方式，一种是连续读取，该模式电源一直处于打开状态，还有一种是单次读取模式，此模式每次读取结束之后都会自动关闭电源，以达到节能的目的。 本次驱动中并没有写这一部分，只分了快速连续模式和精确连续模式，或许以后用到会再进行完善，或者如果大家有兴趣可以添加这部分简单的代码推送到我的github仓库，我会将好的代码merge进去。 三、结语#最近写博客的质量下降的很厉害，我自己也有感觉到，但是最近实在是太累了，每天很晚才回到家中。每天都在学习没有接触过得新鲜知识，感觉没有太多的精力去对以前的项目做博客分享这些事情，但我还是会坚持下去的，毕竟这是自己喜欢的事情。现在是凌晨1:30分，我已经困倦不堪，希望等我下一次闲下来的时候能够好好地再梳理一下我想要分享的这些东西。 本次项目的例程在我的github仓库上：https://github.com/gengyuchao/ESP8266_example/tree/master/project_BH1750 欢迎大家来我的博客评论和给我留言，或者给我的github项目点星星，提issue，提交pull request。把更多更好更有趣的知识传递下去。O(∩_∩)O哈哈~","link":"/2020/08/09/ESP8266%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP8266%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_BH1750%E5%85%89%E5%BC%BA%E4%BC%A0%E6%84%9F%E5%99%A8/"},{"title":"ESP8266开发学习笔记_ws2812三原色灯","text":"ESP8266 开发学习笔记_By_GYC 【spi方式驱动 ws2812 三原色灯（稳定优化）】 本章介绍ESP8266 IDF 框架下 如何使用 骚操作 的使用SPI总线，发送更高精度的脉冲信号，ws2812作为控制芯片三色灯的使用方法，实现三原色显示灯带。在研究过程中，发现ESP8266的引脚响应速度有些慢，输出2.5us才能够翻转一次，而ws2812的控制电平分辨率要求在百纳秒级，所以需要其他方法来输出控制信号才能保证灯光稳定。本次选用SPI信号输出口，使灯光达到了稳定。 一、驱动ws2812遇到的问题 二、可能的方案 三、具体实现 一、驱动ws2812遇到的问题#在淘宝上偶然看见有只需要一个引脚就能高速的控制三原色全彩LED灯，这让我很感兴趣，就买下来回来尝试，结果到手当天就遇到了很严重的问题，根据手册的说明写了一下简单的驱动程序，灯亮是能亮但是只有一个颜色，没有办法像网上说的那样能够自由的调节颜色，搞得我很是崩溃，还以为自己的编程水平出了问题，明明代码逻辑已经没有什么问题了，却还是不能正常显示，我就喊朋友来帮忙驱动一下，他用stm32的开发板，十几分钟就从网上扣下源码给我驱动了，代码逻辑和我的相差无几。 那么确定不是代码的问题了，就要找找其他的问题，比如我正在研究的单片机ESP8266。放到示波器上显示GPIO引脚的输出电平可以发现，引脚的实际输出速度并不像程序设计的那样，实际操作时ESP8266的管脚每2.5us（0.4MHz）才能够进行一次有效的翻转，而ws2812的控制电平要求精度在百ns级别，普通的GPIO管脚并不能达到这样的速度，而stm32的引脚翻转速度远大于ESP8266的，其I/O口驱动电路的响应速度有2M、10M、50M可选，轻松就能达到百纳秒的精度。所以stm32能够轻松的驱动ws2812而ESP8266只能通过骚操作来实现。 二、可能的方案#1、特殊GPIO 一般如stm32主频比较高的单片机，可以直接通过驱动GPIO引脚，控制引脚的翻转，实现对ws2812的控制。虽然ESP8266的GPIO翻转速度无法达到期望的速度，但是根据网上其他人的分享，发现ESP8266的GPIO0的翻转速度和响应速度都比片上其他的GPIO快，可以作为ws2812的驱动引脚。经过测试，发现配合寄存器操作的GPIO0确实能够驱动ws2812、并且能够显示色彩进行调节。不过这种方法稳定性较低，不知道是我使用的芯片问题还是普遍存在，用GPIO0驱动的ws2812灯圈（8个）不稳定，偶尔就会一个灯珠颜色错误。这让我很是难受。 2、使用pwm驱动 PWM，周期设置为3MHz，发送0就把占空比设置为33%，发送1就把占空比设置为66%。也是一种很有创意的驱动方式。可惜的是ESP8266的PWM功能是通过定时器用GPIO翻转模拟的，它的PWM 周期范围是：1000us (1KHz) ~ 10000us (100Hz)，达不到要求。 3、使用SPI方案（本次使用） 可以注意到，将SPI的时钟调整为8MHz，发送一字节是1us，一个比特是0.125us，给ws2812发送逻辑0即可以通过SPI总线发送11000000b来实现（0.25us高电平，0.75us低电平），发送逻辑1即可以通过SPI总线发送11111100b来实现（0.75us高电平，0.25低电平）。通过这种方式驱动的灯光稳定可靠。能够保证灯光不会出现闪烁或者某个灯珠颜色跳变的情况。本次要介绍的ws2812驱动就是使用这种控制方式来实现的。 TODO: 低电平时间0.25us是硬件规定的低电平最小时间，如果能增大一点会更稳定，可以把控制引脚高低的数据改成数据流，比如 TL：1110000000b （0.375us[0.4-0.025] 高电平，0.875us[0.85+0.025] 低电平） 9位 共1.125us TH：1111110000b （0.75us [0.8-0.05] 高电平，0.5us [0.45+0.05] 低电平）9位 共1.125us 高低电平的数据组合组成一长串的 spi 数据，可以使控制更加稳定。 三、具体实现#首先根据ESP8266 的资源信息确认需要用到的引脚。 根据上图所示，ESP8266在nodemcu上的SPI引脚是D5-D8、我们可以通过初始化控制禁用CS和MISO使能，只使用MOSI作为WS2812的输出引脚。设置SPI的时钟频率（SPI clock frequency）为8MHz，使一个字节周期为1.25us。 spi引脚初始化函数如下。 123456789101112131415161718192021222324252627282930313233void ws2812_spi_mode_init(void) //must use the ESP8266 GPIO13 as the hspi pin to drive WS2812B RGB LED!!!{ uint8_t x = 0; ESP_LOGI(\"WS2812\", \"ws2812 init gpio\"); ESP_LOGI(\"WS2812\", \"init hspi\"); spi_config_t spi_config; // Load default interface parameters // CS_EN:1, MISO_EN:1, MOSI_EN:1, BYTE_TX_ORDER:1, BYTE_TX_ORDER:1, BIT_RX_ORDER:0, BIT_TX_ORDER:0, CPHA:0, CPOL:0 spi_config.interface.val = SPI_DEFAULT_INTERFACE; // Load default interrupt enable // TRANS_DONE: true, WRITE_STATUS: false, READ_STATUS: false, WRITE_BUFFER: false, READ_BUFFER: false spi_config.intr_enable.val = SPI_MASTER_DEFAULT_INTR_ENABLE; // Cancel hardware cs spi_config.interface.cs_en = 0; // MISO pin is used for DC spi_config.interface.miso_en = 0; // CPOL: 1, CPHA: 1 spi_config.interface.cpol = 1; spi_config.interface.cpha = 1; // Set SPI to master mode // 8266 Only support half-duplex spi_config.mode = SPI_MASTER_MODE; // Set the SPI clock frequency division factor spi_config.clk_div = SPI_8MHz_DIV; // Register SPI event callback function spi_config.event_cb = spi_event_callback; spi_init(HSPI_HOST, &amp;spi_config); ESP_LOGI(\"WS2812\", \"init over\");} 需要注意的是，这里虽然没有用到，但是你需要设置spi的事件回调函数，即使他是空的 12345678910111213141516171819202122static void IRAM_ATTR spi_event_callback(int event, void *arg){ switch (event) { case SPI_INIT_EVENT: { } break; case SPI_TRANS_START_EVENT: { } break; case SPI_TRANS_DONE_EVENT: { } break; case SPI_DEINIT_EVENT: { } break; }} 准备工作做好之后，我们就要编写数据发送函数了。网上其他的例程里面常常把数据发送函数分为位发送、字节发送、像素点发送三层，层层调用，这种逻辑非常的便于阅读。但是在引脚响应速度并不那么快的单片机上，这种结构并不能保证时序的稳定性，因此，此处我直接略去了前两个过程，直接提供了一个像素数据发送的函数。避免函数切换、SPI重新启动引起的时序不稳定问题。 这个函数在结构上还有待优化，待我闲下来的时候再重构一下，先提供一个能够使用的版本，也希望有高手能够分享这个程序的简化版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void WS2812BSend_24bit(uint8_t R, uint8_t G, uint8_t B){ uint32_t GRB=G&lt;&lt;16|R&lt;&lt;8|B; uint8_t data_buf[24]; uint8_t *p_data=data_buf; //能用 等待优化! uint8_t mask = 0x80; uint8_t byte = G; while (mask) { if( byte &amp; mask ) {*p_data = 0xFC;/*11111100b;*/} else {*p_data = 0XC0;/*11000000b;*/} mask &gt;&gt;= 1; p_data++; } mask = 0x80; byte = R; while (mask) { if( byte &amp; mask ) {*p_data = 0xFC;/*11111100b;*/} else {*p_data = 0XC0;/*11000000b;*/} mask &gt;&gt;= 1; p_data++; } mask = 0x80; byte = B; while (mask) { if( byte &amp; mask ) {*p_data = 0xFC;/*11111100b;*/} else {*p_data = 0XC0;/*11000000b;*/} mask &gt;&gt;= 1; p_data++; } uint8_t* p_8_data; for(int i=0;i&lt;6;i++) { p_8_data=(data_buf+(i*4)); uint8_t temp; for(int j=0;j&lt;2;j++) { temp=p_8_data[j]; p_8_data[j]=p_8_data[3-j]; p_8_data[3-j] = temp; } } uint32_t *spi_buf=(uint32_t*)data_buf; spi_trans_t trans = {0}; trans.mosi = spi_buf; trans.bits.mosi = 24*8; //ETS_INTR_LOCK(); spi_trans(HSPI_HOST, trans); //ETS_INTR_UNLOCK();} 比较麻烦的是，我这里每次传输了192（24*8）bit，由于这是32位的单片机，他是以32bit为单位进行传输的，而且每次都是从低位开始传输。由于ESP8266是小端字节序（与我们的阅读习惯不一致），所以在设置传输的时候需要将数据反一下，保证数据输出的顺序是我们想要的顺序。 以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况 |内存地址 |小端模式存放内容 |大端模式存放内容||：——-： |：——-： |：——-：||0x4000 |0x78| |0x12||0x4001 |0x56| |0x34||0x4002 |0x34| |0x56||0x4003 |0x12| |0x78| 有了如上函数，我们就可以轻松的点亮ws2812三原色灯珠了。 ws2812具体的协议可以参考技术规格书（https://wenku.baidu.com/view/25f176db482fb4daa48d4ba1.html?rec_flag=default&amp;sxts=1561280682919）， 使用到的主要内容如下： 需要注意的是 要保证电源稳定，因为电源问题我遇到了 意外的灯光闪烁、多个灯一起点亮时产生颜色偏差 的问题，更换了供电线和使用5V给模块供电之后，颜色显示完全稳定和正常了。保证硬件良好是软件调试好软件的关键。 四、测试程序 123456789101112131415161718192021222324252627#define PIXEL_MAX 4 //the total numbers of LEDs you are used in your projectuint8_t rBuffer[PIXEL_MAX]={0,0,255,255};uint8_t gBuffer[PIXEL_MAX]={0,255,0,255};uint8_t bBuffer[PIXEL_MAX]={255,0,0,255};void WS2812_Test(void){ //初始化 HSPI 作为数据输出引脚 ws2812_spi_mode_init(); //刷新显示4个LED灯 for(int i=0;i&lt;PIXEL_MAX;i++) { WS2812BSend_24bit(rBuffer[i],gBuffer[i],bBuffer[i]); }}调用我github上写好的库函数进行测试：void app_main(void){ printf(\"SDK version:%s\\n\", esp_get_idf_version()); printf(\"WS2812 Demo\\n\"); WS2812_Init(); //初始化 rainbowCycle(10); //彩虹环} 效果 五、还没结束目前这个项目还未完全完成，还存在一些优化空间，希望大家能够多多和我交流，写出更好的程序。O(∩_∩)O哈哈~ 在此特别感谢“半颗心脏”大佬对我项目的关注，互相学习啦。 我的源文件和头文件已经上传至我的github上（https://github.com/gengyuchao），欢迎大家关注我的博客和github呀。","link":"/2020/08/09/ESP8266%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP8266%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_ws2812%E4%B8%89%E5%8E%9F%E8%89%B2%E7%81%AF/"}],"tags":[{"name":"TEST","slug":"TEST","link":"/tags/TEST/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Bluetooth","slug":"Bluetooth","link":"/tags/Bluetooth/"},{"name":"ESP32","slug":"ESP32","link":"/tags/ESP32/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"IDF","slug":"IDF","link":"/tags/IDF/"},{"name":"ESP8266","slug":"ESP8266","link":"/tags/ESP8266/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"OLED","slug":"OLED","link":"/tags/OLED/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"系统安装","slug":"系统安装","link":"/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"搜狗输入法","slug":"搜狗输入法","link":"/tags/%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95/"},{"name":"Qt","slug":"Qt","link":"/tags/Qt/"},{"name":"浮点数打印","slug":"浮点数打印","link":"/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E6%89%93%E5%8D%B0/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"WS2812","slug":"WS2812","link":"/tags/WS2812/"}],"categories":[{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"Bluetooth学习笔记","slug":"Bluetooth学习笔记","link":"/categories/Bluetooth%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"ESP8266开发学习笔记","slug":"ESP8266开发学习笔记","link":"/categories/ESP8266%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"ESP32","slug":"ESP32","link":"/categories/ESP32/"},{"name":"English","slug":"English","link":"/categories/English/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/categories/Ubuntu/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"}]}